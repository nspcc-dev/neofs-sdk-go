// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.9
// 	protoc        v6.32.1
// source: proto/object/service.proto

package object

import (
	refs "github.com/nspcc-dev/neofs-sdk-go/proto/refs"
	session "github.com/nspcc-dev/neofs-sdk-go/proto/session"
	status "github.com/nspcc-dev/neofs-sdk-go/proto/status"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// GET object request
type GetRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Body of get object request message.
	Body *GetRequest_Body `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// Carries request meta information. Header data is used only to regulate
	// message transport and does not affect request execution.
	MetaHeader *session.RequestMetaHeader `protobuf:"bytes,2,opt,name=meta_header,json=metaHeader,proto3" json:"meta_header,omitempty"`
	// Carries request verification information. This header is used to
	// authenticate the nodes of the message route and check the correctness of
	// transmission.
	VerifyHeader  *session.RequestVerificationHeader `protobuf:"bytes,3,opt,name=verify_header,json=verifyHeader,proto3" json:"verify_header,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetRequest) Reset() {
	*x = GetRequest{}
	mi := &file_proto_object_service_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRequest) ProtoMessage() {}

func (x *GetRequest) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRequest.ProtoReflect.Descriptor instead.
func (*GetRequest) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{0}
}

func (x *GetRequest) GetBody() *GetRequest_Body {
	if x != nil {
		return x.Body
	}
	return nil
}

func (x *GetRequest) GetMetaHeader() *session.RequestMetaHeader {
	if x != nil {
		return x.MetaHeader
	}
	return nil
}

func (x *GetRequest) GetVerifyHeader() *session.RequestVerificationHeader {
	if x != nil {
		return x.VerifyHeader
	}
	return nil
}

// GET object response
type GetResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Body of get object response message.
	Body *GetResponse_Body `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// Carries response meta information. Header data is used only to regulate
	// message transport and does not affect request execution.
	MetaHeader *session.ResponseMetaHeader `protobuf:"bytes,2,opt,name=meta_header,json=metaHeader,proto3" json:"meta_header,omitempty"`
	// Carries response verification information. This header is used to
	// authenticate the nodes of the message route and check the correctness of
	// transmission.
	// DEPRECATED: Verify header and payload checksums instead. Servers MUST
	// attach it for requests with `meta_header.version` <= 2.17.
	VerifyHeader  *session.ResponseVerificationHeader `protobuf:"bytes,3,opt,name=verify_header,json=verifyHeader,proto3" json:"verify_header,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetResponse) Reset() {
	*x = GetResponse{}
	mi := &file_proto_object_service_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetResponse) ProtoMessage() {}

func (x *GetResponse) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetResponse.ProtoReflect.Descriptor instead.
func (*GetResponse) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{1}
}

func (x *GetResponse) GetBody() *GetResponse_Body {
	if x != nil {
		return x.Body
	}
	return nil
}

func (x *GetResponse) GetMetaHeader() *session.ResponseMetaHeader {
	if x != nil {
		return x.MetaHeader
	}
	return nil
}

func (x *GetResponse) GetVerifyHeader() *session.ResponseVerificationHeader {
	if x != nil {
		return x.VerifyHeader
	}
	return nil
}

// PUT object request
type PutRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Body of put object request message.
	Body *PutRequest_Body `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// Carries request meta information. Header data is used only to regulate
	// message transport and does not affect request execution.
	MetaHeader *session.RequestMetaHeader `protobuf:"bytes,2,opt,name=meta_header,json=metaHeader,proto3" json:"meta_header,omitempty"`
	// Carries request verification information. This header is used to
	// authenticate the nodes of the message route and check the correctness of
	// transmission.
	VerifyHeader  *session.RequestVerificationHeader `protobuf:"bytes,3,opt,name=verify_header,json=verifyHeader,proto3" json:"verify_header,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PutRequest) Reset() {
	*x = PutRequest{}
	mi := &file_proto_object_service_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PutRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PutRequest) ProtoMessage() {}

func (x *PutRequest) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PutRequest.ProtoReflect.Descriptor instead.
func (*PutRequest) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{2}
}

func (x *PutRequest) GetBody() *PutRequest_Body {
	if x != nil {
		return x.Body
	}
	return nil
}

func (x *PutRequest) GetMetaHeader() *session.RequestMetaHeader {
	if x != nil {
		return x.MetaHeader
	}
	return nil
}

func (x *PutRequest) GetVerifyHeader() *session.RequestVerificationHeader {
	if x != nil {
		return x.VerifyHeader
	}
	return nil
}

// PUT Object response
type PutResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Body of put object response message.
	Body *PutResponse_Body `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// Carries response meta information. Header data is used only to regulate
	// message transport and does not affect request execution.
	MetaHeader *session.ResponseMetaHeader `protobuf:"bytes,2,opt,name=meta_header,json=metaHeader,proto3" json:"meta_header,omitempty"`
	// Carries response verification information. This header is used to
	// authenticate the nodes of the message route and check the correctness of
	// transmission.
	VerifyHeader  *session.ResponseVerificationHeader `protobuf:"bytes,3,opt,name=verify_header,json=verifyHeader,proto3" json:"verify_header,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PutResponse) Reset() {
	*x = PutResponse{}
	mi := &file_proto_object_service_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PutResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PutResponse) ProtoMessage() {}

func (x *PutResponse) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PutResponse.ProtoReflect.Descriptor instead.
func (*PutResponse) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{3}
}

func (x *PutResponse) GetBody() *PutResponse_Body {
	if x != nil {
		return x.Body
	}
	return nil
}

func (x *PutResponse) GetMetaHeader() *session.ResponseMetaHeader {
	if x != nil {
		return x.MetaHeader
	}
	return nil
}

func (x *PutResponse) GetVerifyHeader() *session.ResponseVerificationHeader {
	if x != nil {
		return x.VerifyHeader
	}
	return nil
}

// Object DELETE request
type DeleteRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Body of delete object request message.
	Body *DeleteRequest_Body `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// Carries request meta information. Header data is used only to regulate
	// message transport and does not affect request execution.
	MetaHeader *session.RequestMetaHeader `protobuf:"bytes,2,opt,name=meta_header,json=metaHeader,proto3" json:"meta_header,omitempty"`
	// Carries request verification information. This header is used to
	// authenticate the nodes of the message route and check the correctness of
	// transmission.
	VerifyHeader  *session.RequestVerificationHeader `protobuf:"bytes,3,opt,name=verify_header,json=verifyHeader,proto3" json:"verify_header,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteRequest) Reset() {
	*x = DeleteRequest{}
	mi := &file_proto_object_service_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteRequest) ProtoMessage() {}

func (x *DeleteRequest) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteRequest.ProtoReflect.Descriptor instead.
func (*DeleteRequest) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{4}
}

func (x *DeleteRequest) GetBody() *DeleteRequest_Body {
	if x != nil {
		return x.Body
	}
	return nil
}

func (x *DeleteRequest) GetMetaHeader() *session.RequestMetaHeader {
	if x != nil {
		return x.MetaHeader
	}
	return nil
}

func (x *DeleteRequest) GetVerifyHeader() *session.RequestVerificationHeader {
	if x != nil {
		return x.VerifyHeader
	}
	return nil
}

// DeleteResponse body is empty because we cannot guarantee permanent object
// removal in distributed system.
type DeleteResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Body of delete object response message.
	Body *DeleteResponse_Body `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// Carries response meta information. Header data is used only to regulate
	// message transport and does not affect request execution.
	MetaHeader *session.ResponseMetaHeader `protobuf:"bytes,2,opt,name=meta_header,json=metaHeader,proto3" json:"meta_header,omitempty"`
	// Carries response verification information. This header is used to
	// authenticate the nodes of the message route and check the correctness of
	// transmission.
	VerifyHeader  *session.ResponseVerificationHeader `protobuf:"bytes,3,opt,name=verify_header,json=verifyHeader,proto3" json:"verify_header,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteResponse) Reset() {
	*x = DeleteResponse{}
	mi := &file_proto_object_service_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteResponse) ProtoMessage() {}

func (x *DeleteResponse) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteResponse.ProtoReflect.Descriptor instead.
func (*DeleteResponse) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{5}
}

func (x *DeleteResponse) GetBody() *DeleteResponse_Body {
	if x != nil {
		return x.Body
	}
	return nil
}

func (x *DeleteResponse) GetMetaHeader() *session.ResponseMetaHeader {
	if x != nil {
		return x.MetaHeader
	}
	return nil
}

func (x *DeleteResponse) GetVerifyHeader() *session.ResponseVerificationHeader {
	if x != nil {
		return x.VerifyHeader
	}
	return nil
}

// Object HEAD request
type HeadRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Body of head object request message.
	Body *HeadRequest_Body `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// Carries request meta information. Header data is used only to regulate
	// message transport and does not affect request execution.
	MetaHeader *session.RequestMetaHeader `protobuf:"bytes,2,opt,name=meta_header,json=metaHeader,proto3" json:"meta_header,omitempty"`
	// Carries request verification information. This header is used to
	// authenticate the nodes of the message route and check the correctness of
	// transmission.
	VerifyHeader  *session.RequestVerificationHeader `protobuf:"bytes,3,opt,name=verify_header,json=verifyHeader,proto3" json:"verify_header,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HeadRequest) Reset() {
	*x = HeadRequest{}
	mi := &file_proto_object_service_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HeadRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HeadRequest) ProtoMessage() {}

func (x *HeadRequest) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HeadRequest.ProtoReflect.Descriptor instead.
func (*HeadRequest) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{6}
}

func (x *HeadRequest) GetBody() *HeadRequest_Body {
	if x != nil {
		return x.Body
	}
	return nil
}

func (x *HeadRequest) GetMetaHeader() *session.RequestMetaHeader {
	if x != nil {
		return x.MetaHeader
	}
	return nil
}

func (x *HeadRequest) GetVerifyHeader() *session.RequestVerificationHeader {
	if x != nil {
		return x.VerifyHeader
	}
	return nil
}

// Tuple of a full object header and signature of an `ObjectID`. \
// Signed `ObjectID` is present to verify full header's authenticity through the
// following steps:
//
// 1. Calculate `SHA-256` of the marshalled `Header` structure
// 2. Check if the resulting hash matches `ObjectID`
// 3. Check if `ObjectID` signature in `signature` field is correct
type HeaderWithSignature struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Full object header
	Header *Header `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	// Signed `ObjectID` to verify full header's authenticity
	Signature     *refs.Signature `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HeaderWithSignature) Reset() {
	*x = HeaderWithSignature{}
	mi := &file_proto_object_service_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HeaderWithSignature) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HeaderWithSignature) ProtoMessage() {}

func (x *HeaderWithSignature) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HeaderWithSignature.ProtoReflect.Descriptor instead.
func (*HeaderWithSignature) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{7}
}

func (x *HeaderWithSignature) GetHeader() *Header {
	if x != nil {
		return x.Header
	}
	return nil
}

func (x *HeaderWithSignature) GetSignature() *refs.Signature {
	if x != nil {
		return x.Signature
	}
	return nil
}

// Object HEAD response
type HeadResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Body of head object response message.
	Body *HeadResponse_Body `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// Carries response meta information. Header data is used only to regulate
	// message transport and does not affect request execution.
	MetaHeader *session.ResponseMetaHeader `protobuf:"bytes,2,opt,name=meta_header,json=metaHeader,proto3" json:"meta_header,omitempty"`
	// Carries response verification information. This header is used to
	// authenticate the nodes of the message route and check the correctness of
	// transmission.
	// DEPRECATED: Verify header and payload checksums instead. Servers MUST
	// attach it for requests with `meta_header.version` <= 2.17.
	VerifyHeader  *session.ResponseVerificationHeader `protobuf:"bytes,3,opt,name=verify_header,json=verifyHeader,proto3" json:"verify_header,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HeadResponse) Reset() {
	*x = HeadResponse{}
	mi := &file_proto_object_service_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HeadResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HeadResponse) ProtoMessage() {}

func (x *HeadResponse) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HeadResponse.ProtoReflect.Descriptor instead.
func (*HeadResponse) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{8}
}

func (x *HeadResponse) GetBody() *HeadResponse_Body {
	if x != nil {
		return x.Body
	}
	return nil
}

func (x *HeadResponse) GetMetaHeader() *session.ResponseMetaHeader {
	if x != nil {
		return x.MetaHeader
	}
	return nil
}

func (x *HeadResponse) GetVerifyHeader() *session.ResponseVerificationHeader {
	if x != nil {
		return x.VerifyHeader
	}
	return nil
}

// Object Search request
type SearchRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Body of search object request message.
	Body *SearchRequest_Body `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// Carries request meta information. Header data is used only to regulate
	// message transport and does not affect request execution.
	MetaHeader *session.RequestMetaHeader `protobuf:"bytes,2,opt,name=meta_header,json=metaHeader,proto3" json:"meta_header,omitempty"`
	// Carries request verification information. This header is used to
	// authenticate the nodes of the message route and check the correctness of
	// transmission.
	VerifyHeader  *session.RequestVerificationHeader `protobuf:"bytes,3,opt,name=verify_header,json=verifyHeader,proto3" json:"verify_header,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SearchRequest) Reset() {
	*x = SearchRequest{}
	mi := &file_proto_object_service_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SearchRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SearchRequest) ProtoMessage() {}

func (x *SearchRequest) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SearchRequest.ProtoReflect.Descriptor instead.
func (*SearchRequest) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{9}
}

func (x *SearchRequest) GetBody() *SearchRequest_Body {
	if x != nil {
		return x.Body
	}
	return nil
}

func (x *SearchRequest) GetMetaHeader() *session.RequestMetaHeader {
	if x != nil {
		return x.MetaHeader
	}
	return nil
}

func (x *SearchRequest) GetVerifyHeader() *session.RequestVerificationHeader {
	if x != nil {
		return x.VerifyHeader
	}
	return nil
}

// Search response
type SearchResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Body of search object response message.
	Body *SearchResponse_Body `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// Carries response meta information. Header data is used only to regulate
	// message transport and does not affect request execution.
	MetaHeader *session.ResponseMetaHeader `protobuf:"bytes,2,opt,name=meta_header,json=metaHeader,proto3" json:"meta_header,omitempty"`
	// Carries response verification information. This header is used to
	// authenticate the nodes of the message route and check the correctness of
	// transmission.
	VerifyHeader  *session.ResponseVerificationHeader `protobuf:"bytes,3,opt,name=verify_header,json=verifyHeader,proto3" json:"verify_header,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SearchResponse) Reset() {
	*x = SearchResponse{}
	mi := &file_proto_object_service_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SearchResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SearchResponse) ProtoMessage() {}

func (x *SearchResponse) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SearchResponse.ProtoReflect.Descriptor instead.
func (*SearchResponse) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{10}
}

func (x *SearchResponse) GetBody() *SearchResponse_Body {
	if x != nil {
		return x.Body
	}
	return nil
}

func (x *SearchResponse) GetMetaHeader() *session.ResponseMetaHeader {
	if x != nil {
		return x.MetaHeader
	}
	return nil
}

func (x *SearchResponse) GetVerifyHeader() *session.ResponseVerificationHeader {
	if x != nil {
		return x.VerifyHeader
	}
	return nil
}

// Object SearchV2 request
type SearchV2Request struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Body of search object request message.
	Body *SearchV2Request_Body `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// Carries request meta information. Header data is used only to regulate
	// message transport and does not affect request execution.
	MetaHeader *session.RequestMetaHeader `protobuf:"bytes,2,opt,name=meta_header,json=metaHeader,proto3" json:"meta_header,omitempty"`
	// Carries request verification information. This header is used to
	// authenticate the nodes of the message route and check the correctness of
	// transmission.
	VerifyHeader  *session.RequestVerificationHeader `protobuf:"bytes,3,opt,name=verify_header,json=verifyHeader,proto3" json:"verify_header,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SearchV2Request) Reset() {
	*x = SearchV2Request{}
	mi := &file_proto_object_service_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SearchV2Request) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SearchV2Request) ProtoMessage() {}

func (x *SearchV2Request) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SearchV2Request.ProtoReflect.Descriptor instead.
func (*SearchV2Request) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{11}
}

func (x *SearchV2Request) GetBody() *SearchV2Request_Body {
	if x != nil {
		return x.Body
	}
	return nil
}

func (x *SearchV2Request) GetMetaHeader() *session.RequestMetaHeader {
	if x != nil {
		return x.MetaHeader
	}
	return nil
}

func (x *SearchV2Request) GetVerifyHeader() *session.RequestVerificationHeader {
	if x != nil {
		return x.VerifyHeader
	}
	return nil
}

// SearchV2 response
type SearchV2Response struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Body of search object response message.
	Body *SearchV2Response_Body `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// Carries response meta information. Header data is used only to regulate
	// message transport and does not affect request execution.
	MetaHeader *session.ResponseMetaHeader `protobuf:"bytes,2,opt,name=meta_header,json=metaHeader,proto3" json:"meta_header,omitempty"`
	// Carries response verification information. This header is used to
	// authenticate the nodes of the message route and check the correctness of
	// transmission.
	VerifyHeader  *session.ResponseVerificationHeader `protobuf:"bytes,3,opt,name=verify_header,json=verifyHeader,proto3" json:"verify_header,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SearchV2Response) Reset() {
	*x = SearchV2Response{}
	mi := &file_proto_object_service_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SearchV2Response) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SearchV2Response) ProtoMessage() {}

func (x *SearchV2Response) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SearchV2Response.ProtoReflect.Descriptor instead.
func (*SearchV2Response) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{12}
}

func (x *SearchV2Response) GetBody() *SearchV2Response_Body {
	if x != nil {
		return x.Body
	}
	return nil
}

func (x *SearchV2Response) GetMetaHeader() *session.ResponseMetaHeader {
	if x != nil {
		return x.MetaHeader
	}
	return nil
}

func (x *SearchV2Response) GetVerifyHeader() *session.ResponseVerificationHeader {
	if x != nil {
		return x.VerifyHeader
	}
	return nil
}

// Object payload range. Ranges of zero length SHOULD be considered as invalid
// except for the special 0:0 request which is interpreted as "get whole
// payload" and allows to receive payload only when its size is not known.
type Range struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Offset of the range from the object payload start
	Offset uint64 `protobuf:"varint,1,opt,name=offset,proto3" json:"offset,omitempty"`
	// Length in bytes of the object payload range
	Length        uint64 `protobuf:"varint,2,opt,name=length,proto3" json:"length,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Range) Reset() {
	*x = Range{}
	mi := &file_proto_object_service_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Range) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Range) ProtoMessage() {}

func (x *Range) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Range.ProtoReflect.Descriptor instead.
func (*Range) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{13}
}

func (x *Range) GetOffset() uint64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

func (x *Range) GetLength() uint64 {
	if x != nil {
		return x.Length
	}
	return 0
}

// Request part of object's payload
type GetRangeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Body of get range object request message.
	Body *GetRangeRequest_Body `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// Carries request meta information. Header data is used only to regulate
	// message transport and does not affect request execution.
	MetaHeader *session.RequestMetaHeader `protobuf:"bytes,2,opt,name=meta_header,json=metaHeader,proto3" json:"meta_header,omitempty"`
	// Carries request verification information. This header is used to
	// authenticate the nodes of the message route and check the correctness of
	// transmission.
	VerifyHeader  *session.RequestVerificationHeader `protobuf:"bytes,3,opt,name=verify_header,json=verifyHeader,proto3" json:"verify_header,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetRangeRequest) Reset() {
	*x = GetRangeRequest{}
	mi := &file_proto_object_service_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetRangeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRangeRequest) ProtoMessage() {}

func (x *GetRangeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRangeRequest.ProtoReflect.Descriptor instead.
func (*GetRangeRequest) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{14}
}

func (x *GetRangeRequest) GetBody() *GetRangeRequest_Body {
	if x != nil {
		return x.Body
	}
	return nil
}

func (x *GetRangeRequest) GetMetaHeader() *session.RequestMetaHeader {
	if x != nil {
		return x.MetaHeader
	}
	return nil
}

func (x *GetRangeRequest) GetVerifyHeader() *session.RequestVerificationHeader {
	if x != nil {
		return x.VerifyHeader
	}
	return nil
}

// Get part of object's payload
type GetRangeResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Body of get range object response message.
	Body *GetRangeResponse_Body `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// Carries response meta information. Header data is used only to regulate
	// message transport and does not affect request execution.
	MetaHeader *session.ResponseMetaHeader `protobuf:"bytes,2,opt,name=meta_header,json=metaHeader,proto3" json:"meta_header,omitempty"`
	// Carries response verification information. This header is used to
	// authenticate the nodes of the message route and check the correctness of
	// transmission.
	VerifyHeader  *session.ResponseVerificationHeader `protobuf:"bytes,3,opt,name=verify_header,json=verifyHeader,proto3" json:"verify_header,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetRangeResponse) Reset() {
	*x = GetRangeResponse{}
	mi := &file_proto_object_service_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetRangeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRangeResponse) ProtoMessage() {}

func (x *GetRangeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRangeResponse.ProtoReflect.Descriptor instead.
func (*GetRangeResponse) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{15}
}

func (x *GetRangeResponse) GetBody() *GetRangeResponse_Body {
	if x != nil {
		return x.Body
	}
	return nil
}

func (x *GetRangeResponse) GetMetaHeader() *session.ResponseMetaHeader {
	if x != nil {
		return x.MetaHeader
	}
	return nil
}

func (x *GetRangeResponse) GetVerifyHeader() *session.ResponseVerificationHeader {
	if x != nil {
		return x.VerifyHeader
	}
	return nil
}

// Get hash of object's payload part
type GetRangeHashRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Body of get range hash object request message.
	Body *GetRangeHashRequest_Body `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// Carries request meta information. Header data is used only to regulate
	// message transport and does not affect request execution.
	MetaHeader *session.RequestMetaHeader `protobuf:"bytes,2,opt,name=meta_header,json=metaHeader,proto3" json:"meta_header,omitempty"`
	// Carries request verification information. This header is used to
	// authenticate the nodes of the message route and check the correctness of
	// transmission.
	VerifyHeader  *session.RequestVerificationHeader `protobuf:"bytes,3,opt,name=verify_header,json=verifyHeader,proto3" json:"verify_header,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetRangeHashRequest) Reset() {
	*x = GetRangeHashRequest{}
	mi := &file_proto_object_service_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetRangeHashRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRangeHashRequest) ProtoMessage() {}

func (x *GetRangeHashRequest) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRangeHashRequest.ProtoReflect.Descriptor instead.
func (*GetRangeHashRequest) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{16}
}

func (x *GetRangeHashRequest) GetBody() *GetRangeHashRequest_Body {
	if x != nil {
		return x.Body
	}
	return nil
}

func (x *GetRangeHashRequest) GetMetaHeader() *session.RequestMetaHeader {
	if x != nil {
		return x.MetaHeader
	}
	return nil
}

func (x *GetRangeHashRequest) GetVerifyHeader() *session.RequestVerificationHeader {
	if x != nil {
		return x.VerifyHeader
	}
	return nil
}

// Get hash of object's payload part
type GetRangeHashResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Body of get range hash object response message.
	Body *GetRangeHashResponse_Body `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// Carries response meta information. Header data is used only to regulate
	// message transport and does not affect request execution.
	MetaHeader *session.ResponseMetaHeader `protobuf:"bytes,2,opt,name=meta_header,json=metaHeader,proto3" json:"meta_header,omitempty"`
	// Carries response verification information. This header is used to
	// authenticate the nodes of the message route and check the correctness of
	// transmission.
	VerifyHeader  *session.ResponseVerificationHeader `protobuf:"bytes,3,opt,name=verify_header,json=verifyHeader,proto3" json:"verify_header,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetRangeHashResponse) Reset() {
	*x = GetRangeHashResponse{}
	mi := &file_proto_object_service_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetRangeHashResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRangeHashResponse) ProtoMessage() {}

func (x *GetRangeHashResponse) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRangeHashResponse.ProtoReflect.Descriptor instead.
func (*GetRangeHashResponse) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{17}
}

func (x *GetRangeHashResponse) GetBody() *GetRangeHashResponse_Body {
	if x != nil {
		return x.Body
	}
	return nil
}

func (x *GetRangeHashResponse) GetMetaHeader() *session.ResponseMetaHeader {
	if x != nil {
		return x.MetaHeader
	}
	return nil
}

func (x *GetRangeHashResponse) GetVerifyHeader() *session.ResponseVerificationHeader {
	if x != nil {
		return x.VerifyHeader
	}
	return nil
}

// Replicate RPC request
type ReplicateRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Object to be replicated.
	Object *Object `protobuf:"bytes,1,opt,name=object,proto3" json:"object,omitempty"`
	// Signature of `object.object_id.value` field.
	Signature *refs.Signature `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	// Optional flag that requires server side to attach signature of just
	// replicated object to ensure it has been received correctly. Signature
	// must be calculated with a key that corresponds to an exposed to the
	// network map public key of the object receiver.
	SignObject    bool `protobuf:"varint,3,opt,name=sign_object,json=signObject,proto3" json:"sign_object,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReplicateRequest) Reset() {
	*x = ReplicateRequest{}
	mi := &file_proto_object_service_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReplicateRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReplicateRequest) ProtoMessage() {}

func (x *ReplicateRequest) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReplicateRequest.ProtoReflect.Descriptor instead.
func (*ReplicateRequest) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{18}
}

func (x *ReplicateRequest) GetObject() *Object {
	if x != nil {
		return x.Object
	}
	return nil
}

func (x *ReplicateRequest) GetSignature() *refs.Signature {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *ReplicateRequest) GetSignObject() bool {
	if x != nil {
		return x.SignObject
	}
	return false
}

// Replicate RPC response
type ReplicateResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Operation execution status with one of the enumerated codes.
	Status *status.Status `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	// Deterministic ECDSA with SHA-256 hashing (RFC 6979) signature of
	// replicated object. Must be attached if request was made with
	// `sign_object` flag set.
	ObjectSignature []byte `protobuf:"bytes,2,opt,name=object_signature,json=objectSignature,proto3" json:"object_signature,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ReplicateResponse) Reset() {
	*x = ReplicateResponse{}
	mi := &file_proto_object_service_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReplicateResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReplicateResponse) ProtoMessage() {}

func (x *ReplicateResponse) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReplicateResponse.ProtoReflect.Descriptor instead.
func (*ReplicateResponse) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{19}
}

func (x *ReplicateResponse) GetStatus() *status.Status {
	if x != nil {
		return x.Status
	}
	return nil
}

func (x *ReplicateResponse) GetObjectSignature() []byte {
	if x != nil {
		return x.ObjectSignature
	}
	return nil
}

// GET Object request body
type GetRequest_Body struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Address of the requested object
	Address *refs.Address `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// If `raw` flag is set, request will work only with objects that are
	// physically stored on the peer node
	Raw           bool `protobuf:"varint,2,opt,name=raw,proto3" json:"raw,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetRequest_Body) Reset() {
	*x = GetRequest_Body{}
	mi := &file_proto_object_service_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetRequest_Body) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRequest_Body) ProtoMessage() {}

func (x *GetRequest_Body) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRequest_Body.ProtoReflect.Descriptor instead.
func (*GetRequest_Body) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{0, 0}
}

func (x *GetRequest_Body) GetAddress() *refs.Address {
	if x != nil {
		return x.Address
	}
	return nil
}

func (x *GetRequest_Body) GetRaw() bool {
	if x != nil {
		return x.Raw
	}
	return false
}

// GET Object Response body
type GetResponse_Body struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Single message in the response stream.
	//
	// Types that are valid to be assigned to ObjectPart:
	//
	//	*GetResponse_Body_Init_
	//	*GetResponse_Body_Chunk
	//	*GetResponse_Body_SplitInfo
	ObjectPart    isGetResponse_Body_ObjectPart `protobuf_oneof:"object_part"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetResponse_Body) Reset() {
	*x = GetResponse_Body{}
	mi := &file_proto_object_service_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetResponse_Body) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetResponse_Body) ProtoMessage() {}

func (x *GetResponse_Body) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetResponse_Body.ProtoReflect.Descriptor instead.
func (*GetResponse_Body) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{1, 0}
}

func (x *GetResponse_Body) GetObjectPart() isGetResponse_Body_ObjectPart {
	if x != nil {
		return x.ObjectPart
	}
	return nil
}

func (x *GetResponse_Body) GetInit() *GetResponse_Body_Init {
	if x != nil {
		if x, ok := x.ObjectPart.(*GetResponse_Body_Init_); ok {
			return x.Init
		}
	}
	return nil
}

func (x *GetResponse_Body) GetChunk() []byte {
	if x != nil {
		if x, ok := x.ObjectPart.(*GetResponse_Body_Chunk); ok {
			return x.Chunk
		}
	}
	return nil
}

func (x *GetResponse_Body) GetSplitInfo() *SplitInfo {
	if x != nil {
		if x, ok := x.ObjectPart.(*GetResponse_Body_SplitInfo); ok {
			return x.SplitInfo
		}
	}
	return nil
}

type isGetResponse_Body_ObjectPart interface {
	isGetResponse_Body_ObjectPart()
}

type GetResponse_Body_Init_ struct {
	// Initial part of the object stream
	Init *GetResponse_Body_Init `protobuf:"bytes,1,opt,name=init,proto3,oneof"`
}

type GetResponse_Body_Chunk struct {
	// Chunked object payload
	Chunk []byte `protobuf:"bytes,2,opt,name=chunk,proto3,oneof"`
}

type GetResponse_Body_SplitInfo struct {
	// Meta information of split hierarchy for object assembly.
	SplitInfo *SplitInfo `protobuf:"bytes,3,opt,name=split_info,json=splitInfo,proto3,oneof"`
}

func (*GetResponse_Body_Init_) isGetResponse_Body_ObjectPart() {}

func (*GetResponse_Body_Chunk) isGetResponse_Body_ObjectPart() {}

func (*GetResponse_Body_SplitInfo) isGetResponse_Body_ObjectPart() {}

// Initial part of the `Object` structure stream. Technically it's a
// set of all `Object` structure's fields except `payload`.
type GetResponse_Body_Init struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Object's unique identifier.
	ObjectId *refs.ObjectID `protobuf:"bytes,1,opt,name=object_id,json=objectId,proto3" json:"object_id,omitempty"`
	// Signed `ObjectID`
	Signature *refs.Signature `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	// Object metadata headers
	Header        *Header `protobuf:"bytes,3,opt,name=header,proto3" json:"header,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetResponse_Body_Init) Reset() {
	*x = GetResponse_Body_Init{}
	mi := &file_proto_object_service_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetResponse_Body_Init) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetResponse_Body_Init) ProtoMessage() {}

func (x *GetResponse_Body_Init) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetResponse_Body_Init.ProtoReflect.Descriptor instead.
func (*GetResponse_Body_Init) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{1, 0, 0}
}

func (x *GetResponse_Body_Init) GetObjectId() *refs.ObjectID {
	if x != nil {
		return x.ObjectId
	}
	return nil
}

func (x *GetResponse_Body_Init) GetSignature() *refs.Signature {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *GetResponse_Body_Init) GetHeader() *Header {
	if x != nil {
		return x.Header
	}
	return nil
}

// PUT request body
type PutRequest_Body struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Single message in the request stream.
	//
	// Types that are valid to be assigned to ObjectPart:
	//
	//	*PutRequest_Body_Init_
	//	*PutRequest_Body_Chunk
	ObjectPart    isPutRequest_Body_ObjectPart `protobuf_oneof:"object_part"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PutRequest_Body) Reset() {
	*x = PutRequest_Body{}
	mi := &file_proto_object_service_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PutRequest_Body) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PutRequest_Body) ProtoMessage() {}

func (x *PutRequest_Body) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PutRequest_Body.ProtoReflect.Descriptor instead.
func (*PutRequest_Body) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{2, 0}
}

func (x *PutRequest_Body) GetObjectPart() isPutRequest_Body_ObjectPart {
	if x != nil {
		return x.ObjectPart
	}
	return nil
}

func (x *PutRequest_Body) GetInit() *PutRequest_Body_Init {
	if x != nil {
		if x, ok := x.ObjectPart.(*PutRequest_Body_Init_); ok {
			return x.Init
		}
	}
	return nil
}

func (x *PutRequest_Body) GetChunk() []byte {
	if x != nil {
		if x, ok := x.ObjectPart.(*PutRequest_Body_Chunk); ok {
			return x.Chunk
		}
	}
	return nil
}

type isPutRequest_Body_ObjectPart interface {
	isPutRequest_Body_ObjectPart()
}

type PutRequest_Body_Init_ struct {
	// Initial part of the object stream
	Init *PutRequest_Body_Init `protobuf:"bytes,1,opt,name=init,proto3,oneof"`
}

type PutRequest_Body_Chunk struct {
	// Chunked object payload
	Chunk []byte `protobuf:"bytes,2,opt,name=chunk,proto3,oneof"`
}

func (*PutRequest_Body_Init_) isPutRequest_Body_ObjectPart() {}

func (*PutRequest_Body_Chunk) isPutRequest_Body_ObjectPart() {}

// Newly created object structure parameters. If some optional parameters
// are not set, they will be calculated by a peer node.
type PutRequest_Body_Init struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// ObjectID if available.
	ObjectId *refs.ObjectID `protobuf:"bytes,1,opt,name=object_id,json=objectId,proto3" json:"object_id,omitempty"`
	// Object signature if available
	Signature *refs.Signature `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	// Object's Header. The maximum length is 16KB.
	Header *Header `protobuf:"bytes,3,opt,name=header,proto3" json:"header,omitempty"`
	// Number of the object copies to store within the RPC call. By default
	// object is processed according to the container's placement policy.
	CopiesNumber  uint32 `protobuf:"varint,4,opt,name=copies_number,json=copiesNumber,proto3" json:"copies_number,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PutRequest_Body_Init) Reset() {
	*x = PutRequest_Body_Init{}
	mi := &file_proto_object_service_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PutRequest_Body_Init) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PutRequest_Body_Init) ProtoMessage() {}

func (x *PutRequest_Body_Init) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PutRequest_Body_Init.ProtoReflect.Descriptor instead.
func (*PutRequest_Body_Init) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{2, 0, 0}
}

func (x *PutRequest_Body_Init) GetObjectId() *refs.ObjectID {
	if x != nil {
		return x.ObjectId
	}
	return nil
}

func (x *PutRequest_Body_Init) GetSignature() *refs.Signature {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *PutRequest_Body_Init) GetHeader() *Header {
	if x != nil {
		return x.Header
	}
	return nil
}

func (x *PutRequest_Body_Init) GetCopiesNumber() uint32 {
	if x != nil {
		return x.CopiesNumber
	}
	return 0
}

// PUT Object response body
type PutResponse_Body struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Identifier of the saved object
	ObjectId      *refs.ObjectID `protobuf:"bytes,1,opt,name=object_id,json=objectId,proto3" json:"object_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PutResponse_Body) Reset() {
	*x = PutResponse_Body{}
	mi := &file_proto_object_service_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PutResponse_Body) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PutResponse_Body) ProtoMessage() {}

func (x *PutResponse_Body) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PutResponse_Body.ProtoReflect.Descriptor instead.
func (*PutResponse_Body) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{3, 0}
}

func (x *PutResponse_Body) GetObjectId() *refs.ObjectID {
	if x != nil {
		return x.ObjectId
	}
	return nil
}

// Object DELETE request body
type DeleteRequest_Body struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Address of the object to be deleted
	Address       *refs.Address `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteRequest_Body) Reset() {
	*x = DeleteRequest_Body{}
	mi := &file_proto_object_service_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteRequest_Body) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteRequest_Body) ProtoMessage() {}

func (x *DeleteRequest_Body) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteRequest_Body.ProtoReflect.Descriptor instead.
func (*DeleteRequest_Body) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{4, 0}
}

func (x *DeleteRequest_Body) GetAddress() *refs.Address {
	if x != nil {
		return x.Address
	}
	return nil
}

// Object DELETE Response has an empty body.
type DeleteResponse_Body struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Address of the tombstone created for the deleted object
	Tombstone     *refs.Address `protobuf:"bytes,1,opt,name=tombstone,proto3" json:"tombstone,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteResponse_Body) Reset() {
	*x = DeleteResponse_Body{}
	mi := &file_proto_object_service_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteResponse_Body) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteResponse_Body) ProtoMessage() {}

func (x *DeleteResponse_Body) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteResponse_Body.ProtoReflect.Descriptor instead.
func (*DeleteResponse_Body) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{5, 0}
}

func (x *DeleteResponse_Body) GetTombstone() *refs.Address {
	if x != nil {
		return x.Tombstone
	}
	return nil
}

// Object HEAD request body
type HeadRequest_Body struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Address of the object with the requested Header
	Address *refs.Address `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// Return only minimal header subset.
	//
	// DEPRECATED. This field is ignored.
	MainOnly bool `protobuf:"varint,2,opt,name=main_only,json=mainOnly,proto3" json:"main_only,omitempty"`
	// If `raw` flag is set, request will work only with objects that are
	// physically stored on the peer node
	Raw           bool `protobuf:"varint,3,opt,name=raw,proto3" json:"raw,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HeadRequest_Body) Reset() {
	*x = HeadRequest_Body{}
	mi := &file_proto_object_service_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HeadRequest_Body) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HeadRequest_Body) ProtoMessage() {}

func (x *HeadRequest_Body) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HeadRequest_Body.ProtoReflect.Descriptor instead.
func (*HeadRequest_Body) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{6, 0}
}

func (x *HeadRequest_Body) GetAddress() *refs.Address {
	if x != nil {
		return x.Address
	}
	return nil
}

func (x *HeadRequest_Body) GetMainOnly() bool {
	if x != nil {
		return x.MainOnly
	}
	return false
}

func (x *HeadRequest_Body) GetRaw() bool {
	if x != nil {
		return x.Raw
	}
	return false
}

// Object HEAD response body
type HeadResponse_Body struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Requested object header, it's part or meta information about split
	// object.
	//
	// Types that are valid to be assigned to Head:
	//
	//	*HeadResponse_Body_Header
	//	*HeadResponse_Body_ShortHeader
	//	*HeadResponse_Body_SplitInfo
	Head          isHeadResponse_Body_Head `protobuf_oneof:"head"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HeadResponse_Body) Reset() {
	*x = HeadResponse_Body{}
	mi := &file_proto_object_service_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HeadResponse_Body) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HeadResponse_Body) ProtoMessage() {}

func (x *HeadResponse_Body) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HeadResponse_Body.ProtoReflect.Descriptor instead.
func (*HeadResponse_Body) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{8, 0}
}

func (x *HeadResponse_Body) GetHead() isHeadResponse_Body_Head {
	if x != nil {
		return x.Head
	}
	return nil
}

func (x *HeadResponse_Body) GetHeader() *HeaderWithSignature {
	if x != nil {
		if x, ok := x.Head.(*HeadResponse_Body_Header); ok {
			return x.Header
		}
	}
	return nil
}

func (x *HeadResponse_Body) GetShortHeader() *ShortHeader {
	if x != nil {
		if x, ok := x.Head.(*HeadResponse_Body_ShortHeader); ok {
			return x.ShortHeader
		}
	}
	return nil
}

func (x *HeadResponse_Body) GetSplitInfo() *SplitInfo {
	if x != nil {
		if x, ok := x.Head.(*HeadResponse_Body_SplitInfo); ok {
			return x.SplitInfo
		}
	}
	return nil
}

type isHeadResponse_Body_Head interface {
	isHeadResponse_Body_Head()
}

type HeadResponse_Body_Header struct {
	// Full object's `Header` with `ObjectID` signature
	Header *HeaderWithSignature `protobuf:"bytes,1,opt,name=header,proto3,oneof"`
}

type HeadResponse_Body_ShortHeader struct {
	// Short object header.
	//
	// DEPRECATED. Use HeaderWithSignature instead.
	ShortHeader *ShortHeader `protobuf:"bytes,2,opt,name=short_header,json=shortHeader,proto3,oneof"`
}

type HeadResponse_Body_SplitInfo struct {
	// Meta information of split hierarchy.
	SplitInfo *SplitInfo `protobuf:"bytes,3,opt,name=split_info,json=splitInfo,proto3,oneof"`
}

func (*HeadResponse_Body_Header) isHeadResponse_Body_Head() {}

func (*HeadResponse_Body_ShortHeader) isHeadResponse_Body_Head() {}

func (*HeadResponse_Body_SplitInfo) isHeadResponse_Body_Head() {}

// Object Search request body
type SearchRequest_Body struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Container identifier were to search
	ContainerId *refs.ContainerID `protobuf:"bytes,1,opt,name=container_id,json=containerId,proto3" json:"container_id,omitempty"`
	// Version of the Query Language used
	Version uint32 `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
	// List of search expressions
	Filters       []*SearchFilter `protobuf:"bytes,3,rep,name=filters,proto3" json:"filters,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SearchRequest_Body) Reset() {
	*x = SearchRequest_Body{}
	mi := &file_proto_object_service_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SearchRequest_Body) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SearchRequest_Body) ProtoMessage() {}

func (x *SearchRequest_Body) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SearchRequest_Body.ProtoReflect.Descriptor instead.
func (*SearchRequest_Body) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{9, 0}
}

func (x *SearchRequest_Body) GetContainerId() *refs.ContainerID {
	if x != nil {
		return x.ContainerId
	}
	return nil
}

func (x *SearchRequest_Body) GetVersion() uint32 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *SearchRequest_Body) GetFilters() []*SearchFilter {
	if x != nil {
		return x.Filters
	}
	return nil
}

// Object Search response body
type SearchResponse_Body struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of `ObjectID`s that match the search query
	IdList        []*refs.ObjectID `protobuf:"bytes,1,rep,name=id_list,json=idList,proto3" json:"id_list,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SearchResponse_Body) Reset() {
	*x = SearchResponse_Body{}
	mi := &file_proto_object_service_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SearchResponse_Body) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SearchResponse_Body) ProtoMessage() {}

func (x *SearchResponse_Body) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SearchResponse_Body.ProtoReflect.Descriptor instead.
func (*SearchResponse_Body) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{10, 0}
}

func (x *SearchResponse_Body) GetIdList() []*refs.ObjectID {
	if x != nil {
		return x.IdList
	}
	return nil
}

// Object Search request body
type SearchV2Request_Body struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Container where the search is being performed.
	ContainerId *refs.ContainerID `protobuf:"bytes,1,opt,name=container_id,json=containerId,proto3" json:"container_id,omitempty"`
	// Version of the Query Language used.
	Version uint32 `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
	// List of search expressions. Limited to 8. If additional attributes are
	// requested (see attributes below) then the first filter's key MUST be
	// the first requested attribute. '$Object:containerID' and
	// '$Object:objectID' filters are prohibited. Numeric filters' values MUST
	// be in range [-MaxUint256, MaxUint256].
	Filters []*SearchFilter `protobuf:"bytes,3,rep,name=filters,proto3" json:"filters,omitempty"`
	// Cursor to continue search. Can be omitted or empty for the new search.
	Cursor string `protobuf:"bytes,4,opt,name=cursor,proto3" json:"cursor,omitempty"`
	// Limits the number of responses to the specified number. Can't be more
	// than 1000.
	Count uint32 `protobuf:"varint,5,opt,name=count,proto3" json:"count,omitempty"`
	// List of attribute names (including special ones as defined by
	// SearchFilter key) to include into the reply. Limited to 8, these
	// attributes also affect result ordering (result is ordered by the 1st one
	// and then by OID). If additional attributes are requested, then the first
	// filter's key (see filters above) MUST be the first requested attribute.
	// '$Object:containerID' and '$Object:objectID' attributes are prohibited.
	// If meta_header.ttl = 1 and the first filter is not STRING_EQUAL,
	// values of the first filtered attribute are requested  automatically.
	Attributes    []string `protobuf:"bytes,6,rep,name=attributes,proto3" json:"attributes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SearchV2Request_Body) Reset() {
	*x = SearchV2Request_Body{}
	mi := &file_proto_object_service_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SearchV2Request_Body) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SearchV2Request_Body) ProtoMessage() {}

func (x *SearchV2Request_Body) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SearchV2Request_Body.ProtoReflect.Descriptor instead.
func (*SearchV2Request_Body) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{11, 0}
}

func (x *SearchV2Request_Body) GetContainerId() *refs.ContainerID {
	if x != nil {
		return x.ContainerId
	}
	return nil
}

func (x *SearchV2Request_Body) GetVersion() uint32 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *SearchV2Request_Body) GetFilters() []*SearchFilter {
	if x != nil {
		return x.Filters
	}
	return nil
}

func (x *SearchV2Request_Body) GetCursor() string {
	if x != nil {
		return x.Cursor
	}
	return ""
}

func (x *SearchV2Request_Body) GetCount() uint32 {
	if x != nil {
		return x.Count
	}
	return 0
}

func (x *SearchV2Request_Body) GetAttributes() []string {
	if x != nil {
		return x.Attributes
	}
	return nil
}

// OID with additional requested metadata.
type SearchV2Response_OIDWithMeta struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Object ID that matches search criteria.
	Id *refs.ObjectID `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// List of attribute data from the respective object, fields
	// strictly follow requested ones. The only exception are attribute-less
	// requests with TTL = 1 and the first non-STRING_EQUAL filter: this field
	// carry value of the first filtered attribute.
	Attributes    []string `protobuf:"bytes,2,rep,name=attributes,proto3" json:"attributes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SearchV2Response_OIDWithMeta) Reset() {
	*x = SearchV2Response_OIDWithMeta{}
	mi := &file_proto_object_service_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SearchV2Response_OIDWithMeta) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SearchV2Response_OIDWithMeta) ProtoMessage() {}

func (x *SearchV2Response_OIDWithMeta) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SearchV2Response_OIDWithMeta.ProtoReflect.Descriptor instead.
func (*SearchV2Response_OIDWithMeta) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{12, 0}
}

func (x *SearchV2Response_OIDWithMeta) GetId() *refs.ObjectID {
	if x != nil {
		return x.Id
	}
	return nil
}

func (x *SearchV2Response_OIDWithMeta) GetAttributes() []string {
	if x != nil {
		return x.Attributes
	}
	return nil
}

// Main result structure.
type SearchV2Response_Body struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of object IDs with additional requested attributes.
	Result []*SearchV2Response_OIDWithMeta `protobuf:"bytes,1,rep,name=result,proto3" json:"result,omitempty"`
	// Cursor that can be used for subsequent requests. For users it's an
	// opaque string that is omitted or empty when there are no more results
	// to list. For nodes to interoperate this is defined as the latest OID
	// for queries without filters and primary (first) attribute value plus
	// OID. Values are encoded in base64.
	Cursor        string `protobuf:"bytes,2,opt,name=cursor,proto3" json:"cursor,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SearchV2Response_Body) Reset() {
	*x = SearchV2Response_Body{}
	mi := &file_proto_object_service_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SearchV2Response_Body) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SearchV2Response_Body) ProtoMessage() {}

func (x *SearchV2Response_Body) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SearchV2Response_Body.ProtoReflect.Descriptor instead.
func (*SearchV2Response_Body) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{12, 1}
}

func (x *SearchV2Response_Body) GetResult() []*SearchV2Response_OIDWithMeta {
	if x != nil {
		return x.Result
	}
	return nil
}

func (x *SearchV2Response_Body) GetCursor() string {
	if x != nil {
		return x.Cursor
	}
	return ""
}

// Byte range of object's payload request body
type GetRangeRequest_Body struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Address of the object containing the requested payload range
	Address *refs.Address `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// Requested payload range
	Range *Range `protobuf:"bytes,2,opt,name=range,proto3" json:"range,omitempty"`
	// If `raw` flag is set, request will work only with objects that are
	// physically stored on the peer node.
	Raw           bool `protobuf:"varint,3,opt,name=raw,proto3" json:"raw,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetRangeRequest_Body) Reset() {
	*x = GetRangeRequest_Body{}
	mi := &file_proto_object_service_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetRangeRequest_Body) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRangeRequest_Body) ProtoMessage() {}

func (x *GetRangeRequest_Body) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRangeRequest_Body.ProtoReflect.Descriptor instead.
func (*GetRangeRequest_Body) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{14, 0}
}

func (x *GetRangeRequest_Body) GetAddress() *refs.Address {
	if x != nil {
		return x.Address
	}
	return nil
}

func (x *GetRangeRequest_Body) GetRange() *Range {
	if x != nil {
		return x.Range
	}
	return nil
}

func (x *GetRangeRequest_Body) GetRaw() bool {
	if x != nil {
		return x.Raw
	}
	return false
}

// Get Range response body uses streams to transfer the response. Because
// object payload considered a byte sequence, there is no need to have some
// initial preamble message. The requested byte range is sent as a series
// chunks.
type GetRangeResponse_Body struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Requested object range or meta information about split object.
	//
	// Types that are valid to be assigned to RangePart:
	//
	//	*GetRangeResponse_Body_Chunk
	//	*GetRangeResponse_Body_SplitInfo
	RangePart     isGetRangeResponse_Body_RangePart `protobuf_oneof:"range_part"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetRangeResponse_Body) Reset() {
	*x = GetRangeResponse_Body{}
	mi := &file_proto_object_service_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetRangeResponse_Body) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRangeResponse_Body) ProtoMessage() {}

func (x *GetRangeResponse_Body) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRangeResponse_Body.ProtoReflect.Descriptor instead.
func (*GetRangeResponse_Body) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{15, 0}
}

func (x *GetRangeResponse_Body) GetRangePart() isGetRangeResponse_Body_RangePart {
	if x != nil {
		return x.RangePart
	}
	return nil
}

func (x *GetRangeResponse_Body) GetChunk() []byte {
	if x != nil {
		if x, ok := x.RangePart.(*GetRangeResponse_Body_Chunk); ok {
			return x.Chunk
		}
	}
	return nil
}

func (x *GetRangeResponse_Body) GetSplitInfo() *SplitInfo {
	if x != nil {
		if x, ok := x.RangePart.(*GetRangeResponse_Body_SplitInfo); ok {
			return x.SplitInfo
		}
	}
	return nil
}

type isGetRangeResponse_Body_RangePart interface {
	isGetRangeResponse_Body_RangePart()
}

type GetRangeResponse_Body_Chunk struct {
	// Chunked object payload's range.
	Chunk []byte `protobuf:"bytes,1,opt,name=chunk,proto3,oneof"`
}

type GetRangeResponse_Body_SplitInfo struct {
	// Meta information of split hierarchy.
	SplitInfo *SplitInfo `protobuf:"bytes,2,opt,name=split_info,json=splitInfo,proto3,oneof"`
}

func (*GetRangeResponse_Body_Chunk) isGetRangeResponse_Body_RangePart() {}

func (*GetRangeResponse_Body_SplitInfo) isGetRangeResponse_Body_RangePart() {}

// Get hash of object's payload part request body.
type GetRangeHashRequest_Body struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Address of the object that containing the requested payload range
	Address *refs.Address `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// List of object's payload ranges to calculate homomorphic hash
	Ranges []*Range `protobuf:"bytes,2,rep,name=ranges,proto3" json:"ranges,omitempty"`
	// Binary salt to XOR object's payload ranges before hash calculation
	Salt []byte `protobuf:"bytes,3,opt,name=salt,proto3" json:"salt,omitempty"`
	// Checksum algorithm type
	Type          refs.ChecksumType `protobuf:"varint,4,opt,name=type,proto3,enum=neo.fs.v2.refs.ChecksumType" json:"type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetRangeHashRequest_Body) Reset() {
	*x = GetRangeHashRequest_Body{}
	mi := &file_proto_object_service_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetRangeHashRequest_Body) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRangeHashRequest_Body) ProtoMessage() {}

func (x *GetRangeHashRequest_Body) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRangeHashRequest_Body.ProtoReflect.Descriptor instead.
func (*GetRangeHashRequest_Body) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{16, 0}
}

func (x *GetRangeHashRequest_Body) GetAddress() *refs.Address {
	if x != nil {
		return x.Address
	}
	return nil
}

func (x *GetRangeHashRequest_Body) GetRanges() []*Range {
	if x != nil {
		return x.Ranges
	}
	return nil
}

func (x *GetRangeHashRequest_Body) GetSalt() []byte {
	if x != nil {
		return x.Salt
	}
	return nil
}

func (x *GetRangeHashRequest_Body) GetType() refs.ChecksumType {
	if x != nil {
		return x.Type
	}
	return refs.ChecksumType(0)
}

// Get hash of object's payload part response body.
type GetRangeHashResponse_Body struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Checksum algorithm type
	Type refs.ChecksumType `protobuf:"varint,1,opt,name=type,proto3,enum=neo.fs.v2.refs.ChecksumType" json:"type,omitempty"`
	// List of range hashes in a binary format
	HashList      [][]byte `protobuf:"bytes,2,rep,name=hash_list,json=hashList,proto3" json:"hash_list,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetRangeHashResponse_Body) Reset() {
	*x = GetRangeHashResponse_Body{}
	mi := &file_proto_object_service_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetRangeHashResponse_Body) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRangeHashResponse_Body) ProtoMessage() {}

func (x *GetRangeHashResponse_Body) ProtoReflect() protoreflect.Message {
	mi := &file_proto_object_service_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRangeHashResponse_Body.ProtoReflect.Descriptor instead.
func (*GetRangeHashResponse_Body) Descriptor() ([]byte, []int) {
	return file_proto_object_service_proto_rawDescGZIP(), []int{17, 0}
}

func (x *GetRangeHashResponse_Body) GetType() refs.ChecksumType {
	if x != nil {
		return x.Type
	}
	return refs.ChecksumType(0)
}

func (x *GetRangeHashResponse_Body) GetHashList() [][]byte {
	if x != nil {
		return x.HashList
	}
	return nil
}

var File_proto_object_service_proto protoreflect.FileDescriptor

const file_proto_object_service_proto_rawDesc = "" +
	"\n" +
	"\x1aproto/object/service.proto\x12\x10neo.fs.v2.object\x1a\x18proto/object/types.proto\x1a\x16proto/refs/types.proto\x1a\x19proto/session/types.proto\x1a\x18proto/status/types.proto\"\xaa\x02\n" +
	"\n" +
	"GetRequest\x125\n" +
	"\x04body\x18\x01 \x01(\v2!.neo.fs.v2.object.GetRequest.BodyR\x04body\x12E\n" +
	"\vmeta_header\x18\x02 \x01(\v2$.neo.fs.v2.session.RequestMetaHeaderR\n" +
	"metaHeader\x12Q\n" +
	"\rverify_header\x18\x03 \x01(\v2,.neo.fs.v2.session.RequestVerificationHeaderR\fverifyHeader\x1aK\n" +
	"\x04Body\x121\n" +
	"\aaddress\x18\x01 \x01(\v2\x17.neo.fs.v2.refs.AddressR\aaddress\x12\x10\n" +
	"\x03raw\x18\x02 \x01(\bR\x03raw\"\xb9\x04\n" +
	"\vGetResponse\x126\n" +
	"\x04body\x18\x01 \x01(\v2\".neo.fs.v2.object.GetResponse.BodyR\x04body\x12F\n" +
	"\vmeta_header\x18\x02 \x01(\v2%.neo.fs.v2.session.ResponseMetaHeaderR\n" +
	"metaHeader\x12R\n" +
	"\rverify_header\x18\x03 \x01(\v2-.neo.fs.v2.session.ResponseVerificationHeaderR\fverifyHeader\x1a\xd5\x02\n" +
	"\x04Body\x12=\n" +
	"\x04init\x18\x01 \x01(\v2'.neo.fs.v2.object.GetResponse.Body.InitH\x00R\x04init\x12\x16\n" +
	"\x05chunk\x18\x02 \x01(\fH\x00R\x05chunk\x12<\n" +
	"\n" +
	"split_info\x18\x03 \x01(\v2\x1b.neo.fs.v2.object.SplitInfoH\x00R\tsplitInfo\x1a\xa8\x01\n" +
	"\x04Init\x125\n" +
	"\tobject_id\x18\x01 \x01(\v2\x18.neo.fs.v2.refs.ObjectIDR\bobjectId\x127\n" +
	"\tsignature\x18\x02 \x01(\v2\x19.neo.fs.v2.refs.SignatureR\tsignature\x120\n" +
	"\x06header\x18\x03 \x01(\v2\x18.neo.fs.v2.object.HeaderR\x06headerB\r\n" +
	"\vobject_part\"\x9b\x04\n" +
	"\n" +
	"PutRequest\x125\n" +
	"\x04body\x18\x01 \x01(\v2!.neo.fs.v2.object.PutRequest.BodyR\x04body\x12E\n" +
	"\vmeta_header\x18\x02 \x01(\v2$.neo.fs.v2.session.RequestMetaHeaderR\n" +
	"metaHeader\x12Q\n" +
	"\rverify_header\x18\x03 \x01(\v2,.neo.fs.v2.session.RequestVerificationHeaderR\fverifyHeader\x1a\xbb\x02\n" +
	"\x04Body\x12<\n" +
	"\x04init\x18\x01 \x01(\v2&.neo.fs.v2.object.PutRequest.Body.InitH\x00R\x04init\x12\x16\n" +
	"\x05chunk\x18\x02 \x01(\fH\x00R\x05chunk\x1a\xcd\x01\n" +
	"\x04Init\x125\n" +
	"\tobject_id\x18\x01 \x01(\v2\x18.neo.fs.v2.refs.ObjectIDR\bobjectId\x127\n" +
	"\tsignature\x18\x02 \x01(\v2\x19.neo.fs.v2.refs.SignatureR\tsignature\x120\n" +
	"\x06header\x18\x03 \x01(\v2\x18.neo.fs.v2.object.HeaderR\x06header\x12#\n" +
	"\rcopies_number\x18\x04 \x01(\rR\fcopiesNumberB\r\n" +
	"\vobject_part\"\xa0\x02\n" +
	"\vPutResponse\x126\n" +
	"\x04body\x18\x01 \x01(\v2\".neo.fs.v2.object.PutResponse.BodyR\x04body\x12F\n" +
	"\vmeta_header\x18\x02 \x01(\v2%.neo.fs.v2.session.ResponseMetaHeaderR\n" +
	"metaHeader\x12R\n" +
	"\rverify_header\x18\x03 \x01(\v2-.neo.fs.v2.session.ResponseVerificationHeaderR\fverifyHeader\x1a=\n" +
	"\x04Body\x125\n" +
	"\tobject_id\x18\x01 \x01(\v2\x18.neo.fs.v2.refs.ObjectIDR\bobjectId\"\x9e\x02\n" +
	"\rDeleteRequest\x128\n" +
	"\x04body\x18\x01 \x01(\v2$.neo.fs.v2.object.DeleteRequest.BodyR\x04body\x12E\n" +
	"\vmeta_header\x18\x02 \x01(\v2$.neo.fs.v2.session.RequestMetaHeaderR\n" +
	"metaHeader\x12Q\n" +
	"\rverify_header\x18\x03 \x01(\v2,.neo.fs.v2.session.RequestVerificationHeaderR\fverifyHeader\x1a9\n" +
	"\x04Body\x121\n" +
	"\aaddress\x18\x01 \x01(\v2\x17.neo.fs.v2.refs.AddressR\aaddress\"\xa6\x02\n" +
	"\x0eDeleteResponse\x129\n" +
	"\x04body\x18\x01 \x01(\v2%.neo.fs.v2.object.DeleteResponse.BodyR\x04body\x12F\n" +
	"\vmeta_header\x18\x02 \x01(\v2%.neo.fs.v2.session.ResponseMetaHeaderR\n" +
	"metaHeader\x12R\n" +
	"\rverify_header\x18\x03 \x01(\v2-.neo.fs.v2.session.ResponseVerificationHeaderR\fverifyHeader\x1a=\n" +
	"\x04Body\x125\n" +
	"\ttombstone\x18\x01 \x01(\v2\x17.neo.fs.v2.refs.AddressR\ttombstone\"\xc9\x02\n" +
	"\vHeadRequest\x126\n" +
	"\x04body\x18\x01 \x01(\v2\".neo.fs.v2.object.HeadRequest.BodyR\x04body\x12E\n" +
	"\vmeta_header\x18\x02 \x01(\v2$.neo.fs.v2.session.RequestMetaHeaderR\n" +
	"metaHeader\x12Q\n" +
	"\rverify_header\x18\x03 \x01(\v2,.neo.fs.v2.session.RequestVerificationHeaderR\fverifyHeader\x1ah\n" +
	"\x04Body\x121\n" +
	"\aaddress\x18\x01 \x01(\v2\x17.neo.fs.v2.refs.AddressR\aaddress\x12\x1b\n" +
	"\tmain_only\x18\x02 \x01(\bR\bmainOnly\x12\x10\n" +
	"\x03raw\x18\x03 \x01(\bR\x03raw\"\x80\x01\n" +
	"\x13HeaderWithSignature\x120\n" +
	"\x06header\x18\x01 \x01(\v2\x18.neo.fs.v2.object.HeaderR\x06header\x127\n" +
	"\tsignature\x18\x02 \x01(\v2\x19.neo.fs.v2.refs.SignatureR\tsignature\"\xb7\x03\n" +
	"\fHeadResponse\x127\n" +
	"\x04body\x18\x01 \x01(\v2#.neo.fs.v2.object.HeadResponse.BodyR\x04body\x12F\n" +
	"\vmeta_header\x18\x02 \x01(\v2%.neo.fs.v2.session.ResponseMetaHeaderR\n" +
	"metaHeader\x12R\n" +
	"\rverify_header\x18\x03 \x01(\v2-.neo.fs.v2.session.ResponseVerificationHeaderR\fverifyHeader\x1a\xd1\x01\n" +
	"\x04Body\x12?\n" +
	"\x06header\x18\x01 \x01(\v2%.neo.fs.v2.object.HeaderWithSignatureH\x00R\x06header\x12B\n" +
	"\fshort_header\x18\x02 \x01(\v2\x1d.neo.fs.v2.object.ShortHeaderH\x00R\vshortHeader\x12<\n" +
	"\n" +
	"split_info\x18\x03 \x01(\v2\x1b.neo.fs.v2.object.SplitInfoH\x00R\tsplitInfoB\x06\n" +
	"\x04head\"\x80\x03\n" +
	"\rSearchRequest\x128\n" +
	"\x04body\x18\x01 \x01(\v2$.neo.fs.v2.object.SearchRequest.BodyR\x04body\x12E\n" +
	"\vmeta_header\x18\x02 \x01(\v2$.neo.fs.v2.session.RequestMetaHeaderR\n" +
	"metaHeader\x12Q\n" +
	"\rverify_header\x18\x03 \x01(\v2,.neo.fs.v2.session.RequestVerificationHeaderR\fverifyHeader\x1a\x9a\x01\n" +
	"\x04Body\x12>\n" +
	"\fcontainer_id\x18\x01 \x01(\v2\x1b.neo.fs.v2.refs.ContainerIDR\vcontainerId\x12\x18\n" +
	"\aversion\x18\x02 \x01(\rR\aversion\x128\n" +
	"\afilters\x18\x03 \x03(\v2\x1e.neo.fs.v2.object.SearchFilterR\afilters\"\xa2\x02\n" +
	"\x0eSearchResponse\x129\n" +
	"\x04body\x18\x01 \x01(\v2%.neo.fs.v2.object.SearchResponse.BodyR\x04body\x12F\n" +
	"\vmeta_header\x18\x02 \x01(\v2%.neo.fs.v2.session.ResponseMetaHeaderR\n" +
	"metaHeader\x12R\n" +
	"\rverify_header\x18\x03 \x01(\v2-.neo.fs.v2.session.ResponseVerificationHeaderR\fverifyHeader\x1a9\n" +
	"\x04Body\x121\n" +
	"\aid_list\x18\x01 \x03(\v2\x18.neo.fs.v2.refs.ObjectIDR\x06idList\"\xd2\x03\n" +
	"\x0fSearchV2Request\x12:\n" +
	"\x04body\x18\x01 \x01(\v2&.neo.fs.v2.object.SearchV2Request.BodyR\x04body\x12E\n" +
	"\vmeta_header\x18\x02 \x01(\v2$.neo.fs.v2.session.RequestMetaHeaderR\n" +
	"metaHeader\x12Q\n" +
	"\rverify_header\x18\x03 \x01(\v2,.neo.fs.v2.session.RequestVerificationHeaderR\fverifyHeader\x1a\xe8\x01\n" +
	"\x04Body\x12>\n" +
	"\fcontainer_id\x18\x01 \x01(\v2\x1b.neo.fs.v2.refs.ContainerIDR\vcontainerId\x12\x18\n" +
	"\aversion\x18\x02 \x01(\rR\aversion\x128\n" +
	"\afilters\x18\x03 \x03(\v2\x1e.neo.fs.v2.object.SearchFilterR\afilters\x12\x16\n" +
	"\x06cursor\x18\x04 \x01(\tR\x06cursor\x12\x14\n" +
	"\x05count\x18\x05 \x01(\rR\x05count\x12\x1e\n" +
	"\n" +
	"attributes\x18\x06 \x03(\tR\n" +
	"attributes\"\xac\x03\n" +
	"\x10SearchV2Response\x12;\n" +
	"\x04body\x18\x01 \x01(\v2'.neo.fs.v2.object.SearchV2Response.BodyR\x04body\x12F\n" +
	"\vmeta_header\x18\x02 \x01(\v2%.neo.fs.v2.session.ResponseMetaHeaderR\n" +
	"metaHeader\x12R\n" +
	"\rverify_header\x18\x03 \x01(\v2-.neo.fs.v2.session.ResponseVerificationHeaderR\fverifyHeader\x1aW\n" +
	"\vOIDWithMeta\x12(\n" +
	"\x02id\x18\x01 \x01(\v2\x18.neo.fs.v2.refs.ObjectIDR\x02id\x12\x1e\n" +
	"\n" +
	"attributes\x18\x02 \x03(\tR\n" +
	"attributes\x1af\n" +
	"\x04Body\x12F\n" +
	"\x06result\x18\x01 \x03(\v2..neo.fs.v2.object.SearchV2Response.OIDWithMetaR\x06result\x12\x16\n" +
	"\x06cursor\x18\x02 \x01(\tR\x06cursor\"7\n" +
	"\x05Range\x12\x16\n" +
	"\x06offset\x18\x01 \x01(\x04R\x06offset\x12\x16\n" +
	"\x06length\x18\x02 \x01(\x04R\x06length\"\xe3\x02\n" +
	"\x0fGetRangeRequest\x12:\n" +
	"\x04body\x18\x01 \x01(\v2&.neo.fs.v2.object.GetRangeRequest.BodyR\x04body\x12E\n" +
	"\vmeta_header\x18\x02 \x01(\v2$.neo.fs.v2.session.RequestMetaHeaderR\n" +
	"metaHeader\x12Q\n" +
	"\rverify_header\x18\x03 \x01(\v2,.neo.fs.v2.session.RequestVerificationHeaderR\fverifyHeader\x1az\n" +
	"\x04Body\x121\n" +
	"\aaddress\x18\x01 \x01(\v2\x17.neo.fs.v2.refs.AddressR\aaddress\x12-\n" +
	"\x05range\x18\x02 \x01(\v2\x17.neo.fs.v2.object.RangeR\x05range\x12\x10\n" +
	"\x03raw\x18\x03 \x01(\bR\x03raw\"\xd7\x02\n" +
	"\x10GetRangeResponse\x12;\n" +
	"\x04body\x18\x01 \x01(\v2'.neo.fs.v2.object.GetRangeResponse.BodyR\x04body\x12F\n" +
	"\vmeta_header\x18\x02 \x01(\v2%.neo.fs.v2.session.ResponseMetaHeaderR\n" +
	"metaHeader\x12R\n" +
	"\rverify_header\x18\x03 \x01(\v2-.neo.fs.v2.session.ResponseVerificationHeaderR\fverifyHeader\x1aj\n" +
	"\x04Body\x12\x16\n" +
	"\x05chunk\x18\x01 \x01(\fH\x00R\x05chunk\x12<\n" +
	"\n" +
	"split_info\x18\x02 \x01(\v2\x1b.neo.fs.v2.object.SplitInfoH\x00R\tsplitInfoB\f\n" +
	"\n" +
	"range_part\"\xa2\x03\n" +
	"\x13GetRangeHashRequest\x12>\n" +
	"\x04body\x18\x01 \x01(\v2*.neo.fs.v2.object.GetRangeHashRequest.BodyR\x04body\x12E\n" +
	"\vmeta_header\x18\x02 \x01(\v2$.neo.fs.v2.session.RequestMetaHeaderR\n" +
	"metaHeader\x12Q\n" +
	"\rverify_header\x18\x03 \x01(\v2,.neo.fs.v2.session.RequestVerificationHeaderR\fverifyHeader\x1a\xb0\x01\n" +
	"\x04Body\x121\n" +
	"\aaddress\x18\x01 \x01(\v2\x17.neo.fs.v2.refs.AddressR\aaddress\x12/\n" +
	"\x06ranges\x18\x02 \x03(\v2\x17.neo.fs.v2.object.RangeR\x06ranges\x12\x12\n" +
	"\x04salt\x18\x03 \x01(\fR\x04salt\x120\n" +
	"\x04type\x18\x04 \x01(\x0e2\x1c.neo.fs.v2.refs.ChecksumTypeR\x04type\"\xca\x02\n" +
	"\x14GetRangeHashResponse\x12?\n" +
	"\x04body\x18\x01 \x01(\v2+.neo.fs.v2.object.GetRangeHashResponse.BodyR\x04body\x12F\n" +
	"\vmeta_header\x18\x02 \x01(\v2%.neo.fs.v2.session.ResponseMetaHeaderR\n" +
	"metaHeader\x12R\n" +
	"\rverify_header\x18\x03 \x01(\v2-.neo.fs.v2.session.ResponseVerificationHeaderR\fverifyHeader\x1aU\n" +
	"\x04Body\x120\n" +
	"\x04type\x18\x01 \x01(\x0e2\x1c.neo.fs.v2.refs.ChecksumTypeR\x04type\x12\x1b\n" +
	"\thash_list\x18\x02 \x03(\fR\bhashList\"\x9e\x01\n" +
	"\x10ReplicateRequest\x120\n" +
	"\x06object\x18\x01 \x01(\v2\x18.neo.fs.v2.object.ObjectR\x06object\x127\n" +
	"\tsignature\x18\x02 \x01(\v2\x19.neo.fs.v2.refs.SignatureR\tsignature\x12\x1f\n" +
	"\vsign_object\x18\x03 \x01(\bR\n" +
	"signObject\"p\n" +
	"\x11ReplicateResponse\x120\n" +
	"\x06status\x18\x01 \x01(\v2\x18.neo.fs.v2.status.StatusR\x06status\x12)\n" +
	"\x10object_signature\x18\x02 \x01(\fR\x0fobjectSignature2\xdb\x05\n" +
	"\rObjectService\x12D\n" +
	"\x03Get\x12\x1c.neo.fs.v2.object.GetRequest\x1a\x1d.neo.fs.v2.object.GetResponse0\x01\x12D\n" +
	"\x03Put\x12\x1c.neo.fs.v2.object.PutRequest\x1a\x1d.neo.fs.v2.object.PutResponse(\x01\x12K\n" +
	"\x06Delete\x12\x1f.neo.fs.v2.object.DeleteRequest\x1a .neo.fs.v2.object.DeleteResponse\x12E\n" +
	"\x04Head\x12\x1d.neo.fs.v2.object.HeadRequest\x1a\x1e.neo.fs.v2.object.HeadResponse\x12M\n" +
	"\x06Search\x12\x1f.neo.fs.v2.object.SearchRequest\x1a .neo.fs.v2.object.SearchResponse0\x01\x12Q\n" +
	"\bSearchV2\x12!.neo.fs.v2.object.SearchV2Request\x1a\".neo.fs.v2.object.SearchV2Response\x12S\n" +
	"\bGetRange\x12!.neo.fs.v2.object.GetRangeRequest\x1a\".neo.fs.v2.object.GetRangeResponse0\x01\x12]\n" +
	"\fGetRangeHash\x12%.neo.fs.v2.object.GetRangeHashRequest\x1a&.neo.fs.v2.object.GetRangeHashResponse\x12T\n" +
	"\tReplicate\x12\".neo.fs.v2.object.ReplicateRequest\x1a#.neo.fs.v2.object.ReplicateResponseBMZ.github.com/nspcc-dev/neofs-sdk-go/proto/object\xaa\x02\x1aNeo.FileStorage.API.Objectb\x06proto3"

var (
	file_proto_object_service_proto_rawDescOnce sync.Once
	file_proto_object_service_proto_rawDescData []byte
)

func file_proto_object_service_proto_rawDescGZIP() []byte {
	file_proto_object_service_proto_rawDescOnce.Do(func() {
		file_proto_object_service_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_proto_object_service_proto_rawDesc), len(file_proto_object_service_proto_rawDesc)))
	})
	return file_proto_object_service_proto_rawDescData
}

var file_proto_object_service_proto_msgTypes = make([]protoimpl.MessageInfo, 39)
var file_proto_object_service_proto_goTypes = []any{
	(*GetRequest)(nil),                         // 0: neo.fs.v2.object.GetRequest
	(*GetResponse)(nil),                        // 1: neo.fs.v2.object.GetResponse
	(*PutRequest)(nil),                         // 2: neo.fs.v2.object.PutRequest
	(*PutResponse)(nil),                        // 3: neo.fs.v2.object.PutResponse
	(*DeleteRequest)(nil),                      // 4: neo.fs.v2.object.DeleteRequest
	(*DeleteResponse)(nil),                     // 5: neo.fs.v2.object.DeleteResponse
	(*HeadRequest)(nil),                        // 6: neo.fs.v2.object.HeadRequest
	(*HeaderWithSignature)(nil),                // 7: neo.fs.v2.object.HeaderWithSignature
	(*HeadResponse)(nil),                       // 8: neo.fs.v2.object.HeadResponse
	(*SearchRequest)(nil),                      // 9: neo.fs.v2.object.SearchRequest
	(*SearchResponse)(nil),                     // 10: neo.fs.v2.object.SearchResponse
	(*SearchV2Request)(nil),                    // 11: neo.fs.v2.object.SearchV2Request
	(*SearchV2Response)(nil),                   // 12: neo.fs.v2.object.SearchV2Response
	(*Range)(nil),                              // 13: neo.fs.v2.object.Range
	(*GetRangeRequest)(nil),                    // 14: neo.fs.v2.object.GetRangeRequest
	(*GetRangeResponse)(nil),                   // 15: neo.fs.v2.object.GetRangeResponse
	(*GetRangeHashRequest)(nil),                // 16: neo.fs.v2.object.GetRangeHashRequest
	(*GetRangeHashResponse)(nil),               // 17: neo.fs.v2.object.GetRangeHashResponse
	(*ReplicateRequest)(nil),                   // 18: neo.fs.v2.object.ReplicateRequest
	(*ReplicateResponse)(nil),                  // 19: neo.fs.v2.object.ReplicateResponse
	(*GetRequest_Body)(nil),                    // 20: neo.fs.v2.object.GetRequest.Body
	(*GetResponse_Body)(nil),                   // 21: neo.fs.v2.object.GetResponse.Body
	(*GetResponse_Body_Init)(nil),              // 22: neo.fs.v2.object.GetResponse.Body.Init
	(*PutRequest_Body)(nil),                    // 23: neo.fs.v2.object.PutRequest.Body
	(*PutRequest_Body_Init)(nil),               // 24: neo.fs.v2.object.PutRequest.Body.Init
	(*PutResponse_Body)(nil),                   // 25: neo.fs.v2.object.PutResponse.Body
	(*DeleteRequest_Body)(nil),                 // 26: neo.fs.v2.object.DeleteRequest.Body
	(*DeleteResponse_Body)(nil),                // 27: neo.fs.v2.object.DeleteResponse.Body
	(*HeadRequest_Body)(nil),                   // 28: neo.fs.v2.object.HeadRequest.Body
	(*HeadResponse_Body)(nil),                  // 29: neo.fs.v2.object.HeadResponse.Body
	(*SearchRequest_Body)(nil),                 // 30: neo.fs.v2.object.SearchRequest.Body
	(*SearchResponse_Body)(nil),                // 31: neo.fs.v2.object.SearchResponse.Body
	(*SearchV2Request_Body)(nil),               // 32: neo.fs.v2.object.SearchV2Request.Body
	(*SearchV2Response_OIDWithMeta)(nil),       // 33: neo.fs.v2.object.SearchV2Response.OIDWithMeta
	(*SearchV2Response_Body)(nil),              // 34: neo.fs.v2.object.SearchV2Response.Body
	(*GetRangeRequest_Body)(nil),               // 35: neo.fs.v2.object.GetRangeRequest.Body
	(*GetRangeResponse_Body)(nil),              // 36: neo.fs.v2.object.GetRangeResponse.Body
	(*GetRangeHashRequest_Body)(nil),           // 37: neo.fs.v2.object.GetRangeHashRequest.Body
	(*GetRangeHashResponse_Body)(nil),          // 38: neo.fs.v2.object.GetRangeHashResponse.Body
	(*session.RequestMetaHeader)(nil),          // 39: neo.fs.v2.session.RequestMetaHeader
	(*session.RequestVerificationHeader)(nil),  // 40: neo.fs.v2.session.RequestVerificationHeader
	(*session.ResponseMetaHeader)(nil),         // 41: neo.fs.v2.session.ResponseMetaHeader
	(*session.ResponseVerificationHeader)(nil), // 42: neo.fs.v2.session.ResponseVerificationHeader
	(*Header)(nil),                             // 43: neo.fs.v2.object.Header
	(*refs.Signature)(nil),                     // 44: neo.fs.v2.refs.Signature
	(*Object)(nil),                             // 45: neo.fs.v2.object.Object
	(*status.Status)(nil),                      // 46: neo.fs.v2.status.Status
	(*refs.Address)(nil),                       // 47: neo.fs.v2.refs.Address
	(*SplitInfo)(nil),                          // 48: neo.fs.v2.object.SplitInfo
	(*refs.ObjectID)(nil),                      // 49: neo.fs.v2.refs.ObjectID
	(*ShortHeader)(nil),                        // 50: neo.fs.v2.object.ShortHeader
	(*refs.ContainerID)(nil),                   // 51: neo.fs.v2.refs.ContainerID
	(*SearchFilter)(nil),                       // 52: neo.fs.v2.object.SearchFilter
	(refs.ChecksumType)(0),                     // 53: neo.fs.v2.refs.ChecksumType
}
var file_proto_object_service_proto_depIdxs = []int32{
	20, // 0: neo.fs.v2.object.GetRequest.body:type_name -> neo.fs.v2.object.GetRequest.Body
	39, // 1: neo.fs.v2.object.GetRequest.meta_header:type_name -> neo.fs.v2.session.RequestMetaHeader
	40, // 2: neo.fs.v2.object.GetRequest.verify_header:type_name -> neo.fs.v2.session.RequestVerificationHeader
	21, // 3: neo.fs.v2.object.GetResponse.body:type_name -> neo.fs.v2.object.GetResponse.Body
	41, // 4: neo.fs.v2.object.GetResponse.meta_header:type_name -> neo.fs.v2.session.ResponseMetaHeader
	42, // 5: neo.fs.v2.object.GetResponse.verify_header:type_name -> neo.fs.v2.session.ResponseVerificationHeader
	23, // 6: neo.fs.v2.object.PutRequest.body:type_name -> neo.fs.v2.object.PutRequest.Body
	39, // 7: neo.fs.v2.object.PutRequest.meta_header:type_name -> neo.fs.v2.session.RequestMetaHeader
	40, // 8: neo.fs.v2.object.PutRequest.verify_header:type_name -> neo.fs.v2.session.RequestVerificationHeader
	25, // 9: neo.fs.v2.object.PutResponse.body:type_name -> neo.fs.v2.object.PutResponse.Body
	41, // 10: neo.fs.v2.object.PutResponse.meta_header:type_name -> neo.fs.v2.session.ResponseMetaHeader
	42, // 11: neo.fs.v2.object.PutResponse.verify_header:type_name -> neo.fs.v2.session.ResponseVerificationHeader
	26, // 12: neo.fs.v2.object.DeleteRequest.body:type_name -> neo.fs.v2.object.DeleteRequest.Body
	39, // 13: neo.fs.v2.object.DeleteRequest.meta_header:type_name -> neo.fs.v2.session.RequestMetaHeader
	40, // 14: neo.fs.v2.object.DeleteRequest.verify_header:type_name -> neo.fs.v2.session.RequestVerificationHeader
	27, // 15: neo.fs.v2.object.DeleteResponse.body:type_name -> neo.fs.v2.object.DeleteResponse.Body
	41, // 16: neo.fs.v2.object.DeleteResponse.meta_header:type_name -> neo.fs.v2.session.ResponseMetaHeader
	42, // 17: neo.fs.v2.object.DeleteResponse.verify_header:type_name -> neo.fs.v2.session.ResponseVerificationHeader
	28, // 18: neo.fs.v2.object.HeadRequest.body:type_name -> neo.fs.v2.object.HeadRequest.Body
	39, // 19: neo.fs.v2.object.HeadRequest.meta_header:type_name -> neo.fs.v2.session.RequestMetaHeader
	40, // 20: neo.fs.v2.object.HeadRequest.verify_header:type_name -> neo.fs.v2.session.RequestVerificationHeader
	43, // 21: neo.fs.v2.object.HeaderWithSignature.header:type_name -> neo.fs.v2.object.Header
	44, // 22: neo.fs.v2.object.HeaderWithSignature.signature:type_name -> neo.fs.v2.refs.Signature
	29, // 23: neo.fs.v2.object.HeadResponse.body:type_name -> neo.fs.v2.object.HeadResponse.Body
	41, // 24: neo.fs.v2.object.HeadResponse.meta_header:type_name -> neo.fs.v2.session.ResponseMetaHeader
	42, // 25: neo.fs.v2.object.HeadResponse.verify_header:type_name -> neo.fs.v2.session.ResponseVerificationHeader
	30, // 26: neo.fs.v2.object.SearchRequest.body:type_name -> neo.fs.v2.object.SearchRequest.Body
	39, // 27: neo.fs.v2.object.SearchRequest.meta_header:type_name -> neo.fs.v2.session.RequestMetaHeader
	40, // 28: neo.fs.v2.object.SearchRequest.verify_header:type_name -> neo.fs.v2.session.RequestVerificationHeader
	31, // 29: neo.fs.v2.object.SearchResponse.body:type_name -> neo.fs.v2.object.SearchResponse.Body
	41, // 30: neo.fs.v2.object.SearchResponse.meta_header:type_name -> neo.fs.v2.session.ResponseMetaHeader
	42, // 31: neo.fs.v2.object.SearchResponse.verify_header:type_name -> neo.fs.v2.session.ResponseVerificationHeader
	32, // 32: neo.fs.v2.object.SearchV2Request.body:type_name -> neo.fs.v2.object.SearchV2Request.Body
	39, // 33: neo.fs.v2.object.SearchV2Request.meta_header:type_name -> neo.fs.v2.session.RequestMetaHeader
	40, // 34: neo.fs.v2.object.SearchV2Request.verify_header:type_name -> neo.fs.v2.session.RequestVerificationHeader
	34, // 35: neo.fs.v2.object.SearchV2Response.body:type_name -> neo.fs.v2.object.SearchV2Response.Body
	41, // 36: neo.fs.v2.object.SearchV2Response.meta_header:type_name -> neo.fs.v2.session.ResponseMetaHeader
	42, // 37: neo.fs.v2.object.SearchV2Response.verify_header:type_name -> neo.fs.v2.session.ResponseVerificationHeader
	35, // 38: neo.fs.v2.object.GetRangeRequest.body:type_name -> neo.fs.v2.object.GetRangeRequest.Body
	39, // 39: neo.fs.v2.object.GetRangeRequest.meta_header:type_name -> neo.fs.v2.session.RequestMetaHeader
	40, // 40: neo.fs.v2.object.GetRangeRequest.verify_header:type_name -> neo.fs.v2.session.RequestVerificationHeader
	36, // 41: neo.fs.v2.object.GetRangeResponse.body:type_name -> neo.fs.v2.object.GetRangeResponse.Body
	41, // 42: neo.fs.v2.object.GetRangeResponse.meta_header:type_name -> neo.fs.v2.session.ResponseMetaHeader
	42, // 43: neo.fs.v2.object.GetRangeResponse.verify_header:type_name -> neo.fs.v2.session.ResponseVerificationHeader
	37, // 44: neo.fs.v2.object.GetRangeHashRequest.body:type_name -> neo.fs.v2.object.GetRangeHashRequest.Body
	39, // 45: neo.fs.v2.object.GetRangeHashRequest.meta_header:type_name -> neo.fs.v2.session.RequestMetaHeader
	40, // 46: neo.fs.v2.object.GetRangeHashRequest.verify_header:type_name -> neo.fs.v2.session.RequestVerificationHeader
	38, // 47: neo.fs.v2.object.GetRangeHashResponse.body:type_name -> neo.fs.v2.object.GetRangeHashResponse.Body
	41, // 48: neo.fs.v2.object.GetRangeHashResponse.meta_header:type_name -> neo.fs.v2.session.ResponseMetaHeader
	42, // 49: neo.fs.v2.object.GetRangeHashResponse.verify_header:type_name -> neo.fs.v2.session.ResponseVerificationHeader
	45, // 50: neo.fs.v2.object.ReplicateRequest.object:type_name -> neo.fs.v2.object.Object
	44, // 51: neo.fs.v2.object.ReplicateRequest.signature:type_name -> neo.fs.v2.refs.Signature
	46, // 52: neo.fs.v2.object.ReplicateResponse.status:type_name -> neo.fs.v2.status.Status
	47, // 53: neo.fs.v2.object.GetRequest.Body.address:type_name -> neo.fs.v2.refs.Address
	22, // 54: neo.fs.v2.object.GetResponse.Body.init:type_name -> neo.fs.v2.object.GetResponse.Body.Init
	48, // 55: neo.fs.v2.object.GetResponse.Body.split_info:type_name -> neo.fs.v2.object.SplitInfo
	49, // 56: neo.fs.v2.object.GetResponse.Body.Init.object_id:type_name -> neo.fs.v2.refs.ObjectID
	44, // 57: neo.fs.v2.object.GetResponse.Body.Init.signature:type_name -> neo.fs.v2.refs.Signature
	43, // 58: neo.fs.v2.object.GetResponse.Body.Init.header:type_name -> neo.fs.v2.object.Header
	24, // 59: neo.fs.v2.object.PutRequest.Body.init:type_name -> neo.fs.v2.object.PutRequest.Body.Init
	49, // 60: neo.fs.v2.object.PutRequest.Body.Init.object_id:type_name -> neo.fs.v2.refs.ObjectID
	44, // 61: neo.fs.v2.object.PutRequest.Body.Init.signature:type_name -> neo.fs.v2.refs.Signature
	43, // 62: neo.fs.v2.object.PutRequest.Body.Init.header:type_name -> neo.fs.v2.object.Header
	49, // 63: neo.fs.v2.object.PutResponse.Body.object_id:type_name -> neo.fs.v2.refs.ObjectID
	47, // 64: neo.fs.v2.object.DeleteRequest.Body.address:type_name -> neo.fs.v2.refs.Address
	47, // 65: neo.fs.v2.object.DeleteResponse.Body.tombstone:type_name -> neo.fs.v2.refs.Address
	47, // 66: neo.fs.v2.object.HeadRequest.Body.address:type_name -> neo.fs.v2.refs.Address
	7,  // 67: neo.fs.v2.object.HeadResponse.Body.header:type_name -> neo.fs.v2.object.HeaderWithSignature
	50, // 68: neo.fs.v2.object.HeadResponse.Body.short_header:type_name -> neo.fs.v2.object.ShortHeader
	48, // 69: neo.fs.v2.object.HeadResponse.Body.split_info:type_name -> neo.fs.v2.object.SplitInfo
	51, // 70: neo.fs.v2.object.SearchRequest.Body.container_id:type_name -> neo.fs.v2.refs.ContainerID
	52, // 71: neo.fs.v2.object.SearchRequest.Body.filters:type_name -> neo.fs.v2.object.SearchFilter
	49, // 72: neo.fs.v2.object.SearchResponse.Body.id_list:type_name -> neo.fs.v2.refs.ObjectID
	51, // 73: neo.fs.v2.object.SearchV2Request.Body.container_id:type_name -> neo.fs.v2.refs.ContainerID
	52, // 74: neo.fs.v2.object.SearchV2Request.Body.filters:type_name -> neo.fs.v2.object.SearchFilter
	49, // 75: neo.fs.v2.object.SearchV2Response.OIDWithMeta.id:type_name -> neo.fs.v2.refs.ObjectID
	33, // 76: neo.fs.v2.object.SearchV2Response.Body.result:type_name -> neo.fs.v2.object.SearchV2Response.OIDWithMeta
	47, // 77: neo.fs.v2.object.GetRangeRequest.Body.address:type_name -> neo.fs.v2.refs.Address
	13, // 78: neo.fs.v2.object.GetRangeRequest.Body.range:type_name -> neo.fs.v2.object.Range
	48, // 79: neo.fs.v2.object.GetRangeResponse.Body.split_info:type_name -> neo.fs.v2.object.SplitInfo
	47, // 80: neo.fs.v2.object.GetRangeHashRequest.Body.address:type_name -> neo.fs.v2.refs.Address
	13, // 81: neo.fs.v2.object.GetRangeHashRequest.Body.ranges:type_name -> neo.fs.v2.object.Range
	53, // 82: neo.fs.v2.object.GetRangeHashRequest.Body.type:type_name -> neo.fs.v2.refs.ChecksumType
	53, // 83: neo.fs.v2.object.GetRangeHashResponse.Body.type:type_name -> neo.fs.v2.refs.ChecksumType
	0,  // 84: neo.fs.v2.object.ObjectService.Get:input_type -> neo.fs.v2.object.GetRequest
	2,  // 85: neo.fs.v2.object.ObjectService.Put:input_type -> neo.fs.v2.object.PutRequest
	4,  // 86: neo.fs.v2.object.ObjectService.Delete:input_type -> neo.fs.v2.object.DeleteRequest
	6,  // 87: neo.fs.v2.object.ObjectService.Head:input_type -> neo.fs.v2.object.HeadRequest
	9,  // 88: neo.fs.v2.object.ObjectService.Search:input_type -> neo.fs.v2.object.SearchRequest
	11, // 89: neo.fs.v2.object.ObjectService.SearchV2:input_type -> neo.fs.v2.object.SearchV2Request
	14, // 90: neo.fs.v2.object.ObjectService.GetRange:input_type -> neo.fs.v2.object.GetRangeRequest
	16, // 91: neo.fs.v2.object.ObjectService.GetRangeHash:input_type -> neo.fs.v2.object.GetRangeHashRequest
	18, // 92: neo.fs.v2.object.ObjectService.Replicate:input_type -> neo.fs.v2.object.ReplicateRequest
	1,  // 93: neo.fs.v2.object.ObjectService.Get:output_type -> neo.fs.v2.object.GetResponse
	3,  // 94: neo.fs.v2.object.ObjectService.Put:output_type -> neo.fs.v2.object.PutResponse
	5,  // 95: neo.fs.v2.object.ObjectService.Delete:output_type -> neo.fs.v2.object.DeleteResponse
	8,  // 96: neo.fs.v2.object.ObjectService.Head:output_type -> neo.fs.v2.object.HeadResponse
	10, // 97: neo.fs.v2.object.ObjectService.Search:output_type -> neo.fs.v2.object.SearchResponse
	12, // 98: neo.fs.v2.object.ObjectService.SearchV2:output_type -> neo.fs.v2.object.SearchV2Response
	15, // 99: neo.fs.v2.object.ObjectService.GetRange:output_type -> neo.fs.v2.object.GetRangeResponse
	17, // 100: neo.fs.v2.object.ObjectService.GetRangeHash:output_type -> neo.fs.v2.object.GetRangeHashResponse
	19, // 101: neo.fs.v2.object.ObjectService.Replicate:output_type -> neo.fs.v2.object.ReplicateResponse
	93, // [93:102] is the sub-list for method output_type
	84, // [84:93] is the sub-list for method input_type
	84, // [84:84] is the sub-list for extension type_name
	84, // [84:84] is the sub-list for extension extendee
	0,  // [0:84] is the sub-list for field type_name
}

func init() { file_proto_object_service_proto_init() }
func file_proto_object_service_proto_init() {
	if File_proto_object_service_proto != nil {
		return
	}
	file_proto_object_types_proto_init()
	file_proto_object_service_proto_msgTypes[21].OneofWrappers = []any{
		(*GetResponse_Body_Init_)(nil),
		(*GetResponse_Body_Chunk)(nil),
		(*GetResponse_Body_SplitInfo)(nil),
	}
	file_proto_object_service_proto_msgTypes[23].OneofWrappers = []any{
		(*PutRequest_Body_Init_)(nil),
		(*PutRequest_Body_Chunk)(nil),
	}
	file_proto_object_service_proto_msgTypes[29].OneofWrappers = []any{
		(*HeadResponse_Body_Header)(nil),
		(*HeadResponse_Body_ShortHeader)(nil),
		(*HeadResponse_Body_SplitInfo)(nil),
	}
	file_proto_object_service_proto_msgTypes[36].OneofWrappers = []any{
		(*GetRangeResponse_Body_Chunk)(nil),
		(*GetRangeResponse_Body_SplitInfo)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_proto_object_service_proto_rawDesc), len(file_proto_object_service_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   39,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_proto_object_service_proto_goTypes,
		DependencyIndexes: file_proto_object_service_proto_depIdxs,
		MessageInfos:      file_proto_object_service_proto_msgTypes,
	}.Build()
	File_proto_object_service_proto = out.File
	file_proto_object_service_proto_goTypes = nil
	file_proto_object_service_proto_depIdxs = nil
}
