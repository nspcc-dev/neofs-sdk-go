// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.9
// 	protoc        v6.32.1
// source: proto/netmap/types.proto

package netmap

import (
	refs "github.com/nspcc-dev/neofs-sdk-go/proto/refs"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Operations on filters
type Operation int32

const (
	// No Operation defined
	Operation_OPERATION_UNSPECIFIED Operation = 0
	// Equal
	Operation_EQ Operation = 1
	// Not Equal
	Operation_NE Operation = 2
	// Greater then
	Operation_GT Operation = 3
	// Greater or equal
	Operation_GE Operation = 4
	// Less then
	Operation_LT Operation = 5
	// Less or equal
	Operation_LE Operation = 6
	// Logical OR
	Operation_OR Operation = 7
	// Logical AND
	Operation_AND Operation = 8
)

// Enum value maps for Operation.
var (
	Operation_name = map[int32]string{
		0: "OPERATION_UNSPECIFIED",
		1: "EQ",
		2: "NE",
		3: "GT",
		4: "GE",
		5: "LT",
		6: "LE",
		7: "OR",
		8: "AND",
	}
	Operation_value = map[string]int32{
		"OPERATION_UNSPECIFIED": 0,
		"EQ":                    1,
		"NE":                    2,
		"GT":                    3,
		"GE":                    4,
		"LT":                    5,
		"LE":                    6,
		"OR":                    7,
		"AND":                   8,
	}
)

func (x Operation) Enum() *Operation {
	p := new(Operation)
	*p = x
	return p
}

func (x Operation) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Operation) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_netmap_types_proto_enumTypes[0].Descriptor()
}

func (Operation) Type() protoreflect.EnumType {
	return &file_proto_netmap_types_proto_enumTypes[0]
}

func (x Operation) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Operation.Descriptor instead.
func (Operation) EnumDescriptor() ([]byte, []int) {
	return file_proto_netmap_types_proto_rawDescGZIP(), []int{0}
}

// Selector modifier shows how the node set will be formed. By default selector
// just groups nodes into a bucket by attribute, selecting nodes only by their
// hash distance.
type Clause int32

const (
	// No modifier defined. Nodes will be selected from the bucket randomly
	Clause_CLAUSE_UNSPECIFIED Clause = 0
	// SAME will select only nodes having the same value of bucket attribute
	Clause_SAME Clause = 1
	// DISTINCT will select nodes having different values of bucket attribute
	Clause_DISTINCT Clause = 2
)

// Enum value maps for Clause.
var (
	Clause_name = map[int32]string{
		0: "CLAUSE_UNSPECIFIED",
		1: "SAME",
		2: "DISTINCT",
	}
	Clause_value = map[string]int32{
		"CLAUSE_UNSPECIFIED": 0,
		"SAME":               1,
		"DISTINCT":           2,
	}
)

func (x Clause) Enum() *Clause {
	p := new(Clause)
	*p = x
	return p
}

func (x Clause) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Clause) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_netmap_types_proto_enumTypes[1].Descriptor()
}

func (Clause) Type() protoreflect.EnumType {
	return &file_proto_netmap_types_proto_enumTypes[1]
}

func (x Clause) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Clause.Descriptor instead.
func (Clause) EnumDescriptor() ([]byte, []int) {
	return file_proto_netmap_types_proto_rawDescGZIP(), []int{1}
}

// Represents the enumeration of various states of the NeoFS node.
type NodeInfo_State int32

const (
	// Unknown state
	NodeInfo_UNSPECIFIED NodeInfo_State = 0
	// Active state in the network
	NodeInfo_ONLINE NodeInfo_State = 1
	// Network unavailable state
	NodeInfo_OFFLINE NodeInfo_State = 2
	// Maintenance state
	NodeInfo_MAINTENANCE NodeInfo_State = 3
)

// Enum value maps for NodeInfo_State.
var (
	NodeInfo_State_name = map[int32]string{
		0: "UNSPECIFIED",
		1: "ONLINE",
		2: "OFFLINE",
		3: "MAINTENANCE",
	}
	NodeInfo_State_value = map[string]int32{
		"UNSPECIFIED": 0,
		"ONLINE":      1,
		"OFFLINE":     2,
		"MAINTENANCE": 3,
	}
)

func (x NodeInfo_State) Enum() *NodeInfo_State {
	p := new(NodeInfo_State)
	*p = x
	return p
}

func (x NodeInfo_State) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (NodeInfo_State) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_netmap_types_proto_enumTypes[2].Descriptor()
}

func (NodeInfo_State) Type() protoreflect.EnumType {
	return &file_proto_netmap_types_proto_enumTypes[2]
}

func (x NodeInfo_State) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use NodeInfo_State.Descriptor instead.
func (NodeInfo_State) EnumDescriptor() ([]byte, []int) {
	return file_proto_netmap_types_proto_rawDescGZIP(), []int{4, 0}
}

// This filter will return the subset of nodes from `NetworkMap` or another filter's
// results that will satisfy filter's conditions.
type Filter struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Name of the filter or a reference to a named filter. '*' means
	// application to the whole unfiltered NetworkMap. At top level it's used as a
	// filter name. At lower levels it's considered to be a reference to another
	// named filter
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Key to filter
	Key string `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	// Filtering operation
	Op Operation `protobuf:"varint,3,opt,name=op,proto3,enum=neo.fs.v2.netmap.Operation" json:"op,omitempty"`
	// Value to match
	Value string `protobuf:"bytes,4,opt,name=value,proto3" json:"value,omitempty"`
	// List of inner filters. Top level operation will be applied to the whole
	// list.
	Filters       []*Filter `protobuf:"bytes,5,rep,name=filters,proto3" json:"filters,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Filter) Reset() {
	*x = Filter{}
	mi := &file_proto_netmap_types_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Filter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Filter) ProtoMessage() {}

func (x *Filter) ProtoReflect() protoreflect.Message {
	mi := &file_proto_netmap_types_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Filter.ProtoReflect.Descriptor instead.
func (*Filter) Descriptor() ([]byte, []int) {
	return file_proto_netmap_types_proto_rawDescGZIP(), []int{0}
}

func (x *Filter) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Filter) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *Filter) GetOp() Operation {
	if x != nil {
		return x.Op
	}
	return Operation_OPERATION_UNSPECIFIED
}

func (x *Filter) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

func (x *Filter) GetFilters() []*Filter {
	if x != nil {
		return x.Filters
	}
	return nil
}

// Selector chooses a number of nodes from the bucket taking the nearest nodes
// to the provided `ContainerID` by hash distance.
type Selector struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Selector name to reference in object placement section
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// How many nodes to select from the bucket
	Count uint32 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	// Selector modifier showing how to form a bucket
	Clause Clause `protobuf:"varint,3,opt,name=clause,proto3,enum=neo.fs.v2.netmap.Clause" json:"clause,omitempty"`
	// Bucket attribute to select from
	Attribute string `protobuf:"bytes,4,opt,name=attribute,proto3" json:"attribute,omitempty"`
	// Filter reference to select from
	Filter        string `protobuf:"bytes,5,opt,name=filter,proto3" json:"filter,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Selector) Reset() {
	*x = Selector{}
	mi := &file_proto_netmap_types_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Selector) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Selector) ProtoMessage() {}

func (x *Selector) ProtoReflect() protoreflect.Message {
	mi := &file_proto_netmap_types_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Selector.ProtoReflect.Descriptor instead.
func (*Selector) Descriptor() ([]byte, []int) {
	return file_proto_netmap_types_proto_rawDescGZIP(), []int{1}
}

func (x *Selector) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Selector) GetCount() uint32 {
	if x != nil {
		return x.Count
	}
	return 0
}

func (x *Selector) GetClause() Clause {
	if x != nil {
		return x.Clause
	}
	return Clause_CLAUSE_UNSPECIFIED
}

func (x *Selector) GetAttribute() string {
	if x != nil {
		return x.Attribute
	}
	return ""
}

func (x *Selector) GetFilter() string {
	if x != nil {
		return x.Filter
	}
	return ""
}

// Number of object replicas in a set of nodes from the defined selector. If no
// selector set, the root bucket containing all possible nodes will be used by
// default.
type Replica struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// How many object replicas to put. Limited to 8.
	Count uint32 `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
	// Named selector bucket to put replicas
	Selector      string `protobuf:"bytes,2,opt,name=selector,proto3" json:"selector,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Replica) Reset() {
	*x = Replica{}
	mi := &file_proto_netmap_types_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Replica) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Replica) ProtoMessage() {}

func (x *Replica) ProtoReflect() protoreflect.Message {
	mi := &file_proto_netmap_types_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Replica.ProtoReflect.Descriptor instead.
func (*Replica) Descriptor() ([]byte, []int) {
	return file_proto_netmap_types_proto_rawDescGZIP(), []int{2}
}

func (x *Replica) GetCount() uint32 {
	if x != nil {
		return x.Count
	}
	return 0
}

func (x *Replica) GetSelector() string {
	if x != nil {
		return x.Selector
	}
	return ""
}

// Set of rules to select a subset of nodes from `NetworkMap` able to store
// container's objects. The format is simple enough to transpile from different
// storage policy definition languages.
type PlacementPolicy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Rules to set number of object replicas and place each one into a named
	// bucket. Limited to 256 items.
	Replicas []*Replica `protobuf:"bytes,1,rep,name=replicas,proto3" json:"replicas,omitempty"`
	// Container backup factor (CBF) controls how deep NeoFS will search for
	// alternative nodes to include into container's nodes subset. In total,
	// the number of container nodes is Selector (used by Replica) count
	// times CBF. This number is limited to 64 per-Replica and 512 overall.
	ContainerBackupFactor uint32 `protobuf:"varint,2,opt,name=container_backup_factor,json=containerBackupFactor,proto3" json:"container_backup_factor,omitempty"`
	// Set of Selectors to form the container's nodes subset
	Selectors []*Selector `protobuf:"bytes,3,rep,name=selectors,proto3" json:"selectors,omitempty"`
	// List of named filters to reference in selectors
	Filters []*Filter `protobuf:"bytes,4,rep,name=filters,proto3" json:"filters,omitempty"`
	// DEPRECATED. Was used for subnetwork ID to select nodes from, currently
	// ignored.
	//
	// Deprecated: Marked as deprecated in proto/netmap/types.proto.
	SubnetId *refs.SubnetID `protobuf:"bytes,5,opt,name=subnet_id,json=subnetId,proto3" json:"subnet_id,omitempty"`
	// Erasure coding rules. Limited to 4 items.
	EcRules       []*PlacementPolicy_ECRule `protobuf:"bytes,6,rep,name=ec_rules,json=ecRules,proto3" json:"ec_rules,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PlacementPolicy) Reset() {
	*x = PlacementPolicy{}
	mi := &file_proto_netmap_types_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PlacementPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PlacementPolicy) ProtoMessage() {}

func (x *PlacementPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_proto_netmap_types_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PlacementPolicy.ProtoReflect.Descriptor instead.
func (*PlacementPolicy) Descriptor() ([]byte, []int) {
	return file_proto_netmap_types_proto_rawDescGZIP(), []int{3}
}

func (x *PlacementPolicy) GetReplicas() []*Replica {
	if x != nil {
		return x.Replicas
	}
	return nil
}

func (x *PlacementPolicy) GetContainerBackupFactor() uint32 {
	if x != nil {
		return x.ContainerBackupFactor
	}
	return 0
}

func (x *PlacementPolicy) GetSelectors() []*Selector {
	if x != nil {
		return x.Selectors
	}
	return nil
}

func (x *PlacementPolicy) GetFilters() []*Filter {
	if x != nil {
		return x.Filters
	}
	return nil
}

// Deprecated: Marked as deprecated in proto/netmap/types.proto.
func (x *PlacementPolicy) GetSubnetId() *refs.SubnetID {
	if x != nil {
		return x.SubnetId
	}
	return nil
}

func (x *PlacementPolicy) GetEcRules() []*PlacementPolicy_ECRule {
	if x != nil {
		return x.EcRules
	}
	return nil
}

// NeoFS node description
type NodeInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Public key of the NeoFS node in a binary format
	PublicKey []byte `protobuf:"bytes,1,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	// Ways to connect to a node
	Addresses []string `protobuf:"bytes,2,rep,name=addresses,proto3" json:"addresses,omitempty"`
	// Carries list of the NeoFS node attributes in a key-value form. Key name
	// must be a node-unique valid UTF-8 string (without zero bytes). Value can't
	// be empty. NodeInfo structures with duplicated attribute names or
	// attributes with empty values will be considered invalid.
	Attributes []*NodeInfo_Attribute `protobuf:"bytes,3,rep,name=attributes,proto3" json:"attributes,omitempty"`
	// Carries state of the NeoFS node
	State         NodeInfo_State `protobuf:"varint,4,opt,name=state,proto3,enum=neo.fs.v2.netmap.NodeInfo_State" json:"state,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeInfo) Reset() {
	*x = NodeInfo{}
	mi := &file_proto_netmap_types_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeInfo) ProtoMessage() {}

func (x *NodeInfo) ProtoReflect() protoreflect.Message {
	mi := &file_proto_netmap_types_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeInfo.ProtoReflect.Descriptor instead.
func (*NodeInfo) Descriptor() ([]byte, []int) {
	return file_proto_netmap_types_proto_rawDescGZIP(), []int{4}
}

func (x *NodeInfo) GetPublicKey() []byte {
	if x != nil {
		return x.PublicKey
	}
	return nil
}

func (x *NodeInfo) GetAddresses() []string {
	if x != nil {
		return x.Addresses
	}
	return nil
}

func (x *NodeInfo) GetAttributes() []*NodeInfo_Attribute {
	if x != nil {
		return x.Attributes
	}
	return nil
}

func (x *NodeInfo) GetState() NodeInfo_State {
	if x != nil {
		return x.State
	}
	return NodeInfo_UNSPECIFIED
}

// Network map structure
type Netmap struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Network map revision number.
	Epoch uint64 `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	// Nodes presented in network.
	Nodes         []*NodeInfo `protobuf:"bytes,2,rep,name=nodes,proto3" json:"nodes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Netmap) Reset() {
	*x = Netmap{}
	mi := &file_proto_netmap_types_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Netmap) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Netmap) ProtoMessage() {}

func (x *Netmap) ProtoReflect() protoreflect.Message {
	mi := &file_proto_netmap_types_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Netmap.ProtoReflect.Descriptor instead.
func (*Netmap) Descriptor() ([]byte, []int) {
	return file_proto_netmap_types_proto_rawDescGZIP(), []int{5}
}

func (x *Netmap) GetEpoch() uint64 {
	if x != nil {
		return x.Epoch
	}
	return 0
}

func (x *Netmap) GetNodes() []*NodeInfo {
	if x != nil {
		return x.Nodes
	}
	return nil
}

// NeoFS network configuration
type NetworkConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of parameter values
	Parameters    []*NetworkConfig_Parameter `protobuf:"bytes,1,rep,name=parameters,proto3" json:"parameters,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NetworkConfig) Reset() {
	*x = NetworkConfig{}
	mi := &file_proto_netmap_types_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NetworkConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkConfig) ProtoMessage() {}

func (x *NetworkConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_netmap_types_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkConfig.ProtoReflect.Descriptor instead.
func (*NetworkConfig) Descriptor() ([]byte, []int) {
	return file_proto_netmap_types_proto_rawDescGZIP(), []int{6}
}

func (x *NetworkConfig) GetParameters() []*NetworkConfig_Parameter {
	if x != nil {
		return x.Parameters
	}
	return nil
}

// Information about NeoFS network
type NetworkInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Number of the current epoch in the NeoFS network
	CurrentEpoch uint64 `protobuf:"varint,1,opt,name=current_epoch,json=currentEpoch,proto3" json:"current_epoch,omitempty"`
	// Magic number of FS chain of the NeoFS network
	MagicNumber uint64 `protobuf:"varint,2,opt,name=magic_number,json=magicNumber,proto3" json:"magic_number,omitempty"`
	// MillisecondsPerBlock network parameter of FS chain of the NeoFS network
	MsPerBlock int64 `protobuf:"varint,3,opt,name=ms_per_block,json=msPerBlock,proto3" json:"ms_per_block,omitempty"`
	// NeoFS network configuration
	NetworkConfig *NetworkConfig `protobuf:"bytes,4,opt,name=network_config,json=networkConfig,proto3" json:"network_config,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NetworkInfo) Reset() {
	*x = NetworkInfo{}
	mi := &file_proto_netmap_types_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NetworkInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkInfo) ProtoMessage() {}

func (x *NetworkInfo) ProtoReflect() protoreflect.Message {
	mi := &file_proto_netmap_types_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkInfo.ProtoReflect.Descriptor instead.
func (*NetworkInfo) Descriptor() ([]byte, []int) {
	return file_proto_netmap_types_proto_rawDescGZIP(), []int{7}
}

func (x *NetworkInfo) GetCurrentEpoch() uint64 {
	if x != nil {
		return x.CurrentEpoch
	}
	return 0
}

func (x *NetworkInfo) GetMagicNumber() uint64 {
	if x != nil {
		return x.MagicNumber
	}
	return 0
}

func (x *NetworkInfo) GetMsPerBlock() int64 {
	if x != nil {
		return x.MsPerBlock
	}
	return 0
}

func (x *NetworkInfo) GetNetworkConfig() *NetworkConfig {
	if x != nil {
		return x.NetworkConfig
	}
	return nil
}

// Erasure coding rule for container objects.
//
// For each original object, the payload is split into `data_part_num` data
// and `parity_part_num` parity parts. Each part is the same size. Data parts
// contain the original payload. If its length is not divisible by
// `data_part_num`, the last part is aligned with zero bytes. Both
// `data_part_num` and `parity_part_num` MUST NOT be zero or exceed 64,
// including in total. Hashes from all parts are written in the
// `__NEOFS__EC_PART_HASHES` attribute of the original object's header.
//
// For each payload part, a part object is created. Original object's ID,
// signature and header is written in `header.split.parent`,
// `header.split.parent_signature` and `header.split.parent_header` fields
// correspondingly. Part index is written in the `__NEOFS__EC_PART_IDX`
// attribute as base-10 integer. Rule index in `PlacementPolicy.ec_rules`
// list is written in the `__NEOFS__EC_RULE_IDX` attribute as base-10
// integer.
//
// Each part object is stored in the container in one copy. Storage nodes are
// selected from the network map similar to `PlacementPolicy.replicas` rules.
// Optional `selector` acts the same way. The object for the `i`-th part is
// placed in the `i`-th node. If it is unavailable, the backup nodes with
// indexes `m * n + i` (`n = data_part_num + parity_part_num`,
// `m = 1, ..., CBF-1`). If all nodes for the `i`-th part
// are unavailable, nodes for the `i+1`-th (0 for the last) part are tried,
// and so on.
//
// Once part objects are stored in the container, the original object remains
// available if at least `data_part_num` of any part objects are available.
// In other words, unavailability (including complete loss) of any of
// `parity_part_num` part objects does not violate availability of the
// original one.
//
// Objects of TOMBSTONE and LOCK types are not encoded and stored as they are
// because they have no payload.
type PlacementPolicy_ECRule struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Number of data parts
	DataPartNum uint32 `protobuf:"varint,1,opt,name=data_part_num,json=dataPartNum,proto3" json:"data_part_num,omitempty"`
	// Number of parity parts
	ParityPartNum uint32 `protobuf:"varint,2,opt,name=parity_part_num,json=parityPartNum,proto3" json:"parity_part_num,omitempty"`
	// Name of the linked selector
	Selector      string `protobuf:"bytes,3,opt,name=selector,proto3" json:"selector,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PlacementPolicy_ECRule) Reset() {
	*x = PlacementPolicy_ECRule{}
	mi := &file_proto_netmap_types_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PlacementPolicy_ECRule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PlacementPolicy_ECRule) ProtoMessage() {}

func (x *PlacementPolicy_ECRule) ProtoReflect() protoreflect.Message {
	mi := &file_proto_netmap_types_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PlacementPolicy_ECRule.ProtoReflect.Descriptor instead.
func (*PlacementPolicy_ECRule) Descriptor() ([]byte, []int) {
	return file_proto_netmap_types_proto_rawDescGZIP(), []int{3, 0}
}

func (x *PlacementPolicy_ECRule) GetDataPartNum() uint32 {
	if x != nil {
		return x.DataPartNum
	}
	return 0
}

func (x *PlacementPolicy_ECRule) GetParityPartNum() uint32 {
	if x != nil {
		return x.ParityPartNum
	}
	return 0
}

func (x *PlacementPolicy_ECRule) GetSelector() string {
	if x != nil {
		return x.Selector
	}
	return ""
}

// Administrator-defined Attributes of the NeoFS Storage Node.
//
// `Attribute` is a Key-Value metadata pair. Key name must be a valid UTF-8
// string (without zero bytes that are forbidden). Value can't be empty.
//
// Attributes can be constructed into a chain of attributes: any attribute can
// have a parent attribute and a child attribute (except the first and the last
// one). A string representation of the chain of attributes in NeoFS Storage
// Node configuration uses ":" and "/" symbols, e.g.:
//
//	`NEOFS_NODE_ATTRIBUTE_1=key1:val1/key2:val2`
//
// Therefore the string attribute representation in the Node configuration must
// use "\:", "\/" and "\\" escaped symbols if any of them appears in an attribute's
// key or value.
//
// Node's attributes are mostly used during Storage Policy evaluation to
// calculate object's placement and find a set of nodes satisfying policy
// requirements. There are some "well-known" node attributes common to all the
// Storage Nodes in the network and used implicitly with default values if not
// explicitly set:
//
//   - Capacity \
//     Total available disk space in Gigabytes.
//   - Price \
//     Price in GAS tokens for storing one GB of data during one Epoch. In node
//     attributes it's a string presenting floating point number with comma or
//     point delimiter for decimal part. In the Network Map it will be saved as
//     64-bit unsigned integer representing number of minimal token fractions.
//   - __NEOFS__SUBNET_%s \
//     DEPRECATED. Defined if the node is included in the `%s` subnetwork
//     or not. Currently ignored.
//   - UN-LOCODE \
//     Node's geographic location in
//     [UN/LOCODE](https://www.unece.org/cefact/codesfortrade/codes_index.html)
//     format approximated to the nearest point defined in the standard.
//   - CountryCode \
//     Country code in
//     [ISO 3166-1_alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)
//     format. Calculated automatically from `UN-LOCODE` attribute.
//   - Country \
//     Country short name in English, as defined in
//     [ISO-3166](https://www.iso.org/obp/ui/#search). Calculated automatically
//     from `UN-LOCODE` attribute.
//   - Location \
//     Place names are given, whenever possible, in their national language
//     versions as expressed in the Roman alphabet using the 26 characters of
//     the character set adopted for international trade data interchange,
//     written without diacritics . Calculated automatically from `UN-LOCODE`
//     attribute.
//   - SubDivCode \
//     Country's administrative subdivision where node is located. Calculated
//     automatically from `UN-LOCODE` attribute based on `SubDiv` field.
//     Presented in [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2)
//     format.
//   - SubDiv \
//     Country's administrative subdivision name, as defined in
//     [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). Calculated
//     automatically from `UN-LOCODE` attribute.
//   - Continent \
//     Node's continent name according to the [Seven-Continent model]
//     (https://en.wikipedia.org/wiki/Continent#Number). Calculated
//     automatically from `UN-LOCODE` attribute.
//   - ExternalAddr
//     Node's preferred way for communications with external clients.
//     Clients SHOULD use these addresses if possible.
//     Must contain a comma-separated list of multi-addresses.
//     DEPRECATED. Use 'addresses' field instead.
//   - Version
//     Node implementation's version in a free string form.
//   - VerifiedNodesDomain
//     Confirmation of admission to a group of storage nodes.
//     The value is the domain name registered in the NeoFS NNS. If attribute
//     is specified, the storage node requesting entry into the NeoFS network
//     map with this attribute must be included in the access list located on
//     the specified domain. The access list is represented by a set of TXT
//     records: Neo addresses resolved from public keys. To be admitted to the
//     network, Neo address of the node's public key declared in 'public_key'
//     field must be present in domain records. Otherwise, registration will be
//     denied.
//     Value must be a valid NeoFS NNS domain name. Note that if this attribute
//     is absent, this check is not carried out.
//
// For detailed description of each well-known attribute please see the
// corresponding section in NeoFS Technical Specification.
type NodeInfo_Attribute struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Key of the node attribute
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// Value of the node attribute
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// Parent keys, if any. For example for `City` it could be `Region` and
	// `Country`.
	Parents       []string `protobuf:"bytes,3,rep,name=parents,proto3" json:"parents,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeInfo_Attribute) Reset() {
	*x = NodeInfo_Attribute{}
	mi := &file_proto_netmap_types_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeInfo_Attribute) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeInfo_Attribute) ProtoMessage() {}

func (x *NodeInfo_Attribute) ProtoReflect() protoreflect.Message {
	mi := &file_proto_netmap_types_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeInfo_Attribute.ProtoReflect.Descriptor instead.
func (*NodeInfo_Attribute) Descriptor() ([]byte, []int) {
	return file_proto_netmap_types_proto_rawDescGZIP(), []int{4, 0}
}

func (x *NodeInfo_Attribute) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *NodeInfo_Attribute) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

func (x *NodeInfo_Attribute) GetParents() []string {
	if x != nil {
		return x.Parents
	}
	return nil
}

// Single configuration parameter. Key MUST be network-unique.
//
// System parameters:
//   - **AuditFee** \
//     Fee paid by the storage group owner to the Inner Ring member.
//     Value: little-endian integer. Default: 0.
//   - **BasicIncomeRate** \
//     Cost of storing one gigabyte of data for a period of one epoch. Paid by
//     container owner to container nodes.
//     Value: little-endian integer. Default: 0.
//   - **ContainerAliasFee** \
//     Fee paid for named container's creation by the container owner.
//     Value: little-endian integer. Default: 0.
//   - **ContainerFee** \
//     Fee paid for container creation by the container owner.
//     Value: little-endian integer. Default: 0.
//   - **EigenTrustAlpha** \
//     Alpha parameter of EigenTrust algorithm used in the Reputation system.
//     Value: decimal floating-point number in UTF-8 string representation.
//     Default: 0.
//   - **EigenTrustIterations** \
//     Number of EigenTrust algorithm iterations to pass in the Reputation system.
//     Value: little-endian integer. Default: 0.
//   - **EpochDuration** \
//     NeoFS epoch duration measured in seconds.
//     Value: little-endian integer. Default: 0.
//   - **HomomorphicHashingDisabled** \
//     Flag of disabling the homomorphic hashing of objects' payload.
//     Value: true if any byte != 0. Default: false.
//   - **InnerRingCandidateFee** \
//     Fee for entrance to the Inner Ring paid by the candidate.
//     Value: little-endian integer. Default: 0.
//   - **MaintenanceModeAllowed** \
//     Flag allowing setting the MAINTENANCE state to storage nodes.
//     Value: true if any byte != 0. Default: false.
//   - **MaxObjectSize** \
//     Maximum size of physically stored NeoFS object measured in bytes.
//     Value: little-endian integer. Default: 0.
//   - **WithdrawFee** \
//     Fee paid for withdrawal of funds paid by the account owner.
//     Value: little-endian integer. Default: 0.
type NetworkConfig_Parameter struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Parameter key. UTF-8 encoded string (with no zero bytes).
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// Parameter value
	Value         []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NetworkConfig_Parameter) Reset() {
	*x = NetworkConfig_Parameter{}
	mi := &file_proto_netmap_types_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NetworkConfig_Parameter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkConfig_Parameter) ProtoMessage() {}

func (x *NetworkConfig_Parameter) ProtoReflect() protoreflect.Message {
	mi := &file_proto_netmap_types_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkConfig_Parameter.ProtoReflect.Descriptor instead.
func (*NetworkConfig_Parameter) Descriptor() ([]byte, []int) {
	return file_proto_netmap_types_proto_rawDescGZIP(), []int{6, 0}
}

func (x *NetworkConfig_Parameter) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *NetworkConfig_Parameter) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

var File_proto_netmap_types_proto protoreflect.FileDescriptor

const file_proto_netmap_types_proto_rawDesc = "" +
	"\n" +
	"\x18proto/netmap/types.proto\x12\x10neo.fs.v2.netmap\x1a\x16proto/refs/types.proto\"\xa5\x01\n" +
	"\x06Filter\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x10\n" +
	"\x03key\x18\x02 \x01(\tR\x03key\x12+\n" +
	"\x02op\x18\x03 \x01(\x0e2\x1b.neo.fs.v2.netmap.OperationR\x02op\x12\x14\n" +
	"\x05value\x18\x04 \x01(\tR\x05value\x122\n" +
	"\afilters\x18\x05 \x03(\v2\x18.neo.fs.v2.netmap.FilterR\afilters\"\x9c\x01\n" +
	"\bSelector\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x14\n" +
	"\x05count\x18\x02 \x01(\rR\x05count\x120\n" +
	"\x06clause\x18\x03 \x01(\x0e2\x18.neo.fs.v2.netmap.ClauseR\x06clause\x12\x1c\n" +
	"\tattribute\x18\x04 \x01(\tR\tattribute\x12\x16\n" +
	"\x06filter\x18\x05 \x01(\tR\x06filter\";\n" +
	"\aReplica\x12\x14\n" +
	"\x05count\x18\x01 \x01(\rR\x05count\x12\x1a\n" +
	"\bselector\x18\x02 \x01(\tR\bselector\"\xe0\x03\n" +
	"\x0fPlacementPolicy\x125\n" +
	"\breplicas\x18\x01 \x03(\v2\x19.neo.fs.v2.netmap.ReplicaR\breplicas\x126\n" +
	"\x17container_backup_factor\x18\x02 \x01(\rR\x15containerBackupFactor\x128\n" +
	"\tselectors\x18\x03 \x03(\v2\x1a.neo.fs.v2.netmap.SelectorR\tselectors\x122\n" +
	"\afilters\x18\x04 \x03(\v2\x18.neo.fs.v2.netmap.FilterR\afilters\x129\n" +
	"\tsubnet_id\x18\x05 \x01(\v2\x18.neo.fs.v2.refs.SubnetIDB\x02\x18\x01R\bsubnetId\x12C\n" +
	"\bec_rules\x18\x06 \x03(\v2(.neo.fs.v2.netmap.PlacementPolicy.ECRuleR\aecRules\x1ap\n" +
	"\x06ECRule\x12\"\n" +
	"\rdata_part_num\x18\x01 \x01(\rR\vdataPartNum\x12&\n" +
	"\x0fparity_part_num\x18\x02 \x01(\rR\rparityPartNum\x12\x1a\n" +
	"\bselector\x18\x03 \x01(\tR\bselector\"\xd8\x02\n" +
	"\bNodeInfo\x12\x1d\n" +
	"\n" +
	"public_key\x18\x01 \x01(\fR\tpublicKey\x12\x1c\n" +
	"\taddresses\x18\x02 \x03(\tR\taddresses\x12D\n" +
	"\n" +
	"attributes\x18\x03 \x03(\v2$.neo.fs.v2.netmap.NodeInfo.AttributeR\n" +
	"attributes\x126\n" +
	"\x05state\x18\x04 \x01(\x0e2 .neo.fs.v2.netmap.NodeInfo.StateR\x05state\x1aM\n" +
	"\tAttribute\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value\x12\x18\n" +
	"\aparents\x18\x03 \x03(\tR\aparents\"B\n" +
	"\x05State\x12\x0f\n" +
	"\vUNSPECIFIED\x10\x00\x12\n" +
	"\n" +
	"\x06ONLINE\x10\x01\x12\v\n" +
	"\aOFFLINE\x10\x02\x12\x0f\n" +
	"\vMAINTENANCE\x10\x03\"P\n" +
	"\x06Netmap\x12\x14\n" +
	"\x05epoch\x18\x01 \x01(\x04R\x05epoch\x120\n" +
	"\x05nodes\x18\x02 \x03(\v2\x1a.neo.fs.v2.netmap.NodeInfoR\x05nodes\"\x8f\x01\n" +
	"\rNetworkConfig\x12I\n" +
	"\n" +
	"parameters\x18\x01 \x03(\v2).neo.fs.v2.netmap.NetworkConfig.ParameterR\n" +
	"parameters\x1a3\n" +
	"\tParameter\x12\x10\n" +
	"\x03key\x18\x01 \x01(\fR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value\"\xbf\x01\n" +
	"\vNetworkInfo\x12#\n" +
	"\rcurrent_epoch\x18\x01 \x01(\x04R\fcurrentEpoch\x12!\n" +
	"\fmagic_number\x18\x02 \x01(\x04R\vmagicNumber\x12 \n" +
	"\fms_per_block\x18\x03 \x01(\x03R\n" +
	"msPerBlock\x12F\n" +
	"\x0enetwork_config\x18\x04 \x01(\v2\x1f.neo.fs.v2.netmap.NetworkConfigR\rnetworkConfig*g\n" +
	"\tOperation\x12\x19\n" +
	"\x15OPERATION_UNSPECIFIED\x10\x00\x12\x06\n" +
	"\x02EQ\x10\x01\x12\x06\n" +
	"\x02NE\x10\x02\x12\x06\n" +
	"\x02GT\x10\x03\x12\x06\n" +
	"\x02GE\x10\x04\x12\x06\n" +
	"\x02LT\x10\x05\x12\x06\n" +
	"\x02LE\x10\x06\x12\x06\n" +
	"\x02OR\x10\a\x12\a\n" +
	"\x03AND\x10\b*8\n" +
	"\x06Clause\x12\x16\n" +
	"\x12CLAUSE_UNSPECIFIED\x10\x00\x12\b\n" +
	"\x04SAME\x10\x01\x12\f\n" +
	"\bDISTINCT\x10\x02BMZ.github.com/nspcc-dev/neofs-sdk-go/proto/netmap\xaa\x02\x1aNeo.FileStorage.API.Netmapb\x06proto3"

var (
	file_proto_netmap_types_proto_rawDescOnce sync.Once
	file_proto_netmap_types_proto_rawDescData []byte
)

func file_proto_netmap_types_proto_rawDescGZIP() []byte {
	file_proto_netmap_types_proto_rawDescOnce.Do(func() {
		file_proto_netmap_types_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_proto_netmap_types_proto_rawDesc), len(file_proto_netmap_types_proto_rawDesc)))
	})
	return file_proto_netmap_types_proto_rawDescData
}

var file_proto_netmap_types_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_proto_netmap_types_proto_msgTypes = make([]protoimpl.MessageInfo, 11)
var file_proto_netmap_types_proto_goTypes = []any{
	(Operation)(0),                  // 0: neo.fs.v2.netmap.Operation
	(Clause)(0),                     // 1: neo.fs.v2.netmap.Clause
	(NodeInfo_State)(0),             // 2: neo.fs.v2.netmap.NodeInfo.State
	(*Filter)(nil),                  // 3: neo.fs.v2.netmap.Filter
	(*Selector)(nil),                // 4: neo.fs.v2.netmap.Selector
	(*Replica)(nil),                 // 5: neo.fs.v2.netmap.Replica
	(*PlacementPolicy)(nil),         // 6: neo.fs.v2.netmap.PlacementPolicy
	(*NodeInfo)(nil),                // 7: neo.fs.v2.netmap.NodeInfo
	(*Netmap)(nil),                  // 8: neo.fs.v2.netmap.Netmap
	(*NetworkConfig)(nil),           // 9: neo.fs.v2.netmap.NetworkConfig
	(*NetworkInfo)(nil),             // 10: neo.fs.v2.netmap.NetworkInfo
	(*PlacementPolicy_ECRule)(nil),  // 11: neo.fs.v2.netmap.PlacementPolicy.ECRule
	(*NodeInfo_Attribute)(nil),      // 12: neo.fs.v2.netmap.NodeInfo.Attribute
	(*NetworkConfig_Parameter)(nil), // 13: neo.fs.v2.netmap.NetworkConfig.Parameter
	(*refs.SubnetID)(nil),           // 14: neo.fs.v2.refs.SubnetID
}
var file_proto_netmap_types_proto_depIdxs = []int32{
	0,  // 0: neo.fs.v2.netmap.Filter.op:type_name -> neo.fs.v2.netmap.Operation
	3,  // 1: neo.fs.v2.netmap.Filter.filters:type_name -> neo.fs.v2.netmap.Filter
	1,  // 2: neo.fs.v2.netmap.Selector.clause:type_name -> neo.fs.v2.netmap.Clause
	5,  // 3: neo.fs.v2.netmap.PlacementPolicy.replicas:type_name -> neo.fs.v2.netmap.Replica
	4,  // 4: neo.fs.v2.netmap.PlacementPolicy.selectors:type_name -> neo.fs.v2.netmap.Selector
	3,  // 5: neo.fs.v2.netmap.PlacementPolicy.filters:type_name -> neo.fs.v2.netmap.Filter
	14, // 6: neo.fs.v2.netmap.PlacementPolicy.subnet_id:type_name -> neo.fs.v2.refs.SubnetID
	11, // 7: neo.fs.v2.netmap.PlacementPolicy.ec_rules:type_name -> neo.fs.v2.netmap.PlacementPolicy.ECRule
	12, // 8: neo.fs.v2.netmap.NodeInfo.attributes:type_name -> neo.fs.v2.netmap.NodeInfo.Attribute
	2,  // 9: neo.fs.v2.netmap.NodeInfo.state:type_name -> neo.fs.v2.netmap.NodeInfo.State
	7,  // 10: neo.fs.v2.netmap.Netmap.nodes:type_name -> neo.fs.v2.netmap.NodeInfo
	13, // 11: neo.fs.v2.netmap.NetworkConfig.parameters:type_name -> neo.fs.v2.netmap.NetworkConfig.Parameter
	9,  // 12: neo.fs.v2.netmap.NetworkInfo.network_config:type_name -> neo.fs.v2.netmap.NetworkConfig
	13, // [13:13] is the sub-list for method output_type
	13, // [13:13] is the sub-list for method input_type
	13, // [13:13] is the sub-list for extension type_name
	13, // [13:13] is the sub-list for extension extendee
	0,  // [0:13] is the sub-list for field type_name
}

func init() { file_proto_netmap_types_proto_init() }
func file_proto_netmap_types_proto_init() {
	if File_proto_netmap_types_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_proto_netmap_types_proto_rawDesc), len(file_proto_netmap_types_proto_rawDesc)),
			NumEnums:      3,
			NumMessages:   11,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_proto_netmap_types_proto_goTypes,
		DependencyIndexes: file_proto_netmap_types_proto_depIdxs,
		EnumInfos:         file_proto_netmap_types_proto_enumTypes,
		MessageInfos:      file_proto_netmap_types_proto_msgTypes,
	}.Build()
	File_proto_netmap_types_proto = out.File
	file_proto_netmap_types_proto_goTypes = nil
	file_proto_netmap_types_proto_depIdxs = nil
}
