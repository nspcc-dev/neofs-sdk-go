// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.9
// 	protoc        v6.32.1
// source: proto/container/service.proto

package container

import (
	acl "github.com/nspcc-dev/neofs-sdk-go/proto/acl"
	refs "github.com/nspcc-dev/neofs-sdk-go/proto/refs"
	session "github.com/nspcc-dev/neofs-sdk-go/proto/session"
	status "github.com/nspcc-dev/neofs-sdk-go/proto/status"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// New NeoFS Container creation request
type PutRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Body of container put request message.
	Body *PutRequest_Body `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// Carries request meta information. Header data is used only to regulate
	// message transport and does not affect request execution.
	MetaHeader *session.RequestMetaHeader `protobuf:"bytes,2,opt,name=meta_header,json=metaHeader,proto3" json:"meta_header,omitempty"`
	// Carries request verification information. This header is used to
	// authenticate the nodes of the message route and check the correctness of
	// transmission.
	VerifyHeader  *session.RequestVerificationHeader `protobuf:"bytes,3,opt,name=verify_header,json=verifyHeader,proto3" json:"verify_header,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PutRequest) Reset() {
	*x = PutRequest{}
	mi := &file_proto_container_service_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PutRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PutRequest) ProtoMessage() {}

func (x *PutRequest) ProtoReflect() protoreflect.Message {
	mi := &file_proto_container_service_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PutRequest.ProtoReflect.Descriptor instead.
func (*PutRequest) Descriptor() ([]byte, []int) {
	return file_proto_container_service_proto_rawDescGZIP(), []int{0}
}

func (x *PutRequest) GetBody() *PutRequest_Body {
	if x != nil {
		return x.Body
	}
	return nil
}

func (x *PutRequest) GetMetaHeader() *session.RequestMetaHeader {
	if x != nil {
		return x.MetaHeader
	}
	return nil
}

func (x *PutRequest) GetVerifyHeader() *session.RequestVerificationHeader {
	if x != nil {
		return x.VerifyHeader
	}
	return nil
}

// New NeoFS Container creation response
type PutResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Body of container put response message.
	Body *PutResponse_Body `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// Carries response meta information. Header data is used only to regulate
	// message transport and does not affect request execution.
	MetaHeader *session.ResponseMetaHeader `protobuf:"bytes,2,opt,name=meta_header,json=metaHeader,proto3" json:"meta_header,omitempty"`
	// Carries response verification information. This header is used to
	// authenticate the nodes of the message route and check the correctness of
	// transmission.
	VerifyHeader  *session.ResponseVerificationHeader `protobuf:"bytes,3,opt,name=verify_header,json=verifyHeader,proto3" json:"verify_header,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PutResponse) Reset() {
	*x = PutResponse{}
	mi := &file_proto_container_service_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PutResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PutResponse) ProtoMessage() {}

func (x *PutResponse) ProtoReflect() protoreflect.Message {
	mi := &file_proto_container_service_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PutResponse.ProtoReflect.Descriptor instead.
func (*PutResponse) Descriptor() ([]byte, []int) {
	return file_proto_container_service_proto_rawDescGZIP(), []int{1}
}

func (x *PutResponse) GetBody() *PutResponse_Body {
	if x != nil {
		return x.Body
	}
	return nil
}

func (x *PutResponse) GetMetaHeader() *session.ResponseMetaHeader {
	if x != nil {
		return x.MetaHeader
	}
	return nil
}

func (x *PutResponse) GetVerifyHeader() *session.ResponseVerificationHeader {
	if x != nil {
		return x.VerifyHeader
	}
	return nil
}

// Container removal request
type DeleteRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Body of container delete request message.
	Body *DeleteRequest_Body `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// Carries request meta information. Header data is used only to regulate
	// message transport and does not affect request execution.
	MetaHeader *session.RequestMetaHeader `protobuf:"bytes,2,opt,name=meta_header,json=metaHeader,proto3" json:"meta_header,omitempty"`
	// Carries request verification information. This header is used to
	// authenticate the nodes of the message route and check the correctness of
	// transmission.
	VerifyHeader  *session.RequestVerificationHeader `protobuf:"bytes,3,opt,name=verify_header,json=verifyHeader,proto3" json:"verify_header,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteRequest) Reset() {
	*x = DeleteRequest{}
	mi := &file_proto_container_service_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteRequest) ProtoMessage() {}

func (x *DeleteRequest) ProtoReflect() protoreflect.Message {
	mi := &file_proto_container_service_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteRequest.ProtoReflect.Descriptor instead.
func (*DeleteRequest) Descriptor() ([]byte, []int) {
	return file_proto_container_service_proto_rawDescGZIP(), []int{2}
}

func (x *DeleteRequest) GetBody() *DeleteRequest_Body {
	if x != nil {
		return x.Body
	}
	return nil
}

func (x *DeleteRequest) GetMetaHeader() *session.RequestMetaHeader {
	if x != nil {
		return x.MetaHeader
	}
	return nil
}

func (x *DeleteRequest) GetVerifyHeader() *session.RequestVerificationHeader {
	if x != nil {
		return x.VerifyHeader
	}
	return nil
}

// `DeleteResponse` has an empty body because delete operation is asynchronous
// and done via consensus in Inner Ring nodes.
type DeleteResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Body of container delete response message.
	Body *DeleteResponse_Body `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// Carries response meta information. Header data is used only to regulate
	// message transport and does not affect request execution.
	MetaHeader *session.ResponseMetaHeader `protobuf:"bytes,2,opt,name=meta_header,json=metaHeader,proto3" json:"meta_header,omitempty"`
	// Carries response verification information. This header is used to
	// authenticate the nodes of the message route and check the correctness of
	// transmission.
	VerifyHeader  *session.ResponseVerificationHeader `protobuf:"bytes,3,opt,name=verify_header,json=verifyHeader,proto3" json:"verify_header,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteResponse) Reset() {
	*x = DeleteResponse{}
	mi := &file_proto_container_service_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteResponse) ProtoMessage() {}

func (x *DeleteResponse) ProtoReflect() protoreflect.Message {
	mi := &file_proto_container_service_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteResponse.ProtoReflect.Descriptor instead.
func (*DeleteResponse) Descriptor() ([]byte, []int) {
	return file_proto_container_service_proto_rawDescGZIP(), []int{3}
}

func (x *DeleteResponse) GetBody() *DeleteResponse_Body {
	if x != nil {
		return x.Body
	}
	return nil
}

func (x *DeleteResponse) GetMetaHeader() *session.ResponseMetaHeader {
	if x != nil {
		return x.MetaHeader
	}
	return nil
}

func (x *DeleteResponse) GetVerifyHeader() *session.ResponseVerificationHeader {
	if x != nil {
		return x.VerifyHeader
	}
	return nil
}

// Get container structure
type GetRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Body of container get request message.
	Body *GetRequest_Body `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// Carries request meta information. Header data is used only to regulate
	// message transport and does not affect request execution.
	MetaHeader *session.RequestMetaHeader `protobuf:"bytes,2,opt,name=meta_header,json=metaHeader,proto3" json:"meta_header,omitempty"`
	// Carries request verification information. This header is used to
	// authenticate the nodes of the message route and check the correctness of
	// transmission.
	VerifyHeader  *session.RequestVerificationHeader `protobuf:"bytes,3,opt,name=verify_header,json=verifyHeader,proto3" json:"verify_header,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetRequest) Reset() {
	*x = GetRequest{}
	mi := &file_proto_container_service_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRequest) ProtoMessage() {}

func (x *GetRequest) ProtoReflect() protoreflect.Message {
	mi := &file_proto_container_service_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRequest.ProtoReflect.Descriptor instead.
func (*GetRequest) Descriptor() ([]byte, []int) {
	return file_proto_container_service_proto_rawDescGZIP(), []int{4}
}

func (x *GetRequest) GetBody() *GetRequest_Body {
	if x != nil {
		return x.Body
	}
	return nil
}

func (x *GetRequest) GetMetaHeader() *session.RequestMetaHeader {
	if x != nil {
		return x.MetaHeader
	}
	return nil
}

func (x *GetRequest) GetVerifyHeader() *session.RequestVerificationHeader {
	if x != nil {
		return x.VerifyHeader
	}
	return nil
}

// Get container structure
type GetResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Body of container get response message.
	Body *GetResponse_Body `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// Carries response meta information. Header data is used only to regulate
	// message transport and does not affect request execution.
	MetaHeader *session.ResponseMetaHeader `protobuf:"bytes,2,opt,name=meta_header,json=metaHeader,proto3" json:"meta_header,omitempty"`
	// Carries response verification information. This header is used to
	// authenticate the nodes of the message route and check the correctness of
	// transmission.
	VerifyHeader  *session.ResponseVerificationHeader `protobuf:"bytes,3,opt,name=verify_header,json=verifyHeader,proto3" json:"verify_header,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetResponse) Reset() {
	*x = GetResponse{}
	mi := &file_proto_container_service_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetResponse) ProtoMessage() {}

func (x *GetResponse) ProtoReflect() protoreflect.Message {
	mi := &file_proto_container_service_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetResponse.ProtoReflect.Descriptor instead.
func (*GetResponse) Descriptor() ([]byte, []int) {
	return file_proto_container_service_proto_rawDescGZIP(), []int{5}
}

func (x *GetResponse) GetBody() *GetResponse_Body {
	if x != nil {
		return x.Body
	}
	return nil
}

func (x *GetResponse) GetMetaHeader() *session.ResponseMetaHeader {
	if x != nil {
		return x.MetaHeader
	}
	return nil
}

func (x *GetResponse) GetVerifyHeader() *session.ResponseVerificationHeader {
	if x != nil {
		return x.VerifyHeader
	}
	return nil
}

// List containers
type ListRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Body of list containers request message
	Body *ListRequest_Body `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// Carries request meta information. Header data is used only to regulate
	// message transport and does not affect request execution.
	MetaHeader *session.RequestMetaHeader `protobuf:"bytes,2,opt,name=meta_header,json=metaHeader,proto3" json:"meta_header,omitempty"`
	// Carries request verification information. This header is used to
	// authenticate the nodes of the message route and check the correctness of
	// transmission.
	VerifyHeader  *session.RequestVerificationHeader `protobuf:"bytes,3,opt,name=verify_header,json=verifyHeader,proto3" json:"verify_header,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListRequest) Reset() {
	*x = ListRequest{}
	mi := &file_proto_container_service_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListRequest) ProtoMessage() {}

func (x *ListRequest) ProtoReflect() protoreflect.Message {
	mi := &file_proto_container_service_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListRequest.ProtoReflect.Descriptor instead.
func (*ListRequest) Descriptor() ([]byte, []int) {
	return file_proto_container_service_proto_rawDescGZIP(), []int{6}
}

func (x *ListRequest) GetBody() *ListRequest_Body {
	if x != nil {
		return x.Body
	}
	return nil
}

func (x *ListRequest) GetMetaHeader() *session.RequestMetaHeader {
	if x != nil {
		return x.MetaHeader
	}
	return nil
}

func (x *ListRequest) GetVerifyHeader() *session.RequestVerificationHeader {
	if x != nil {
		return x.VerifyHeader
	}
	return nil
}

// List containers
type ListResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Body of list containers response message.
	Body *ListResponse_Body `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// Carries response meta information. Header data is used only to regulate
	// message transport and does not affect request execution.
	MetaHeader *session.ResponseMetaHeader `protobuf:"bytes,2,opt,name=meta_header,json=metaHeader,proto3" json:"meta_header,omitempty"`
	// Carries response verification information. This header is used to
	// authenticate the nodes of the message route and check the correctness of
	// transmission.
	VerifyHeader  *session.ResponseVerificationHeader `protobuf:"bytes,3,opt,name=verify_header,json=verifyHeader,proto3" json:"verify_header,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListResponse) Reset() {
	*x = ListResponse{}
	mi := &file_proto_container_service_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListResponse) ProtoMessage() {}

func (x *ListResponse) ProtoReflect() protoreflect.Message {
	mi := &file_proto_container_service_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListResponse.ProtoReflect.Descriptor instead.
func (*ListResponse) Descriptor() ([]byte, []int) {
	return file_proto_container_service_proto_rawDescGZIP(), []int{7}
}

func (x *ListResponse) GetBody() *ListResponse_Body {
	if x != nil {
		return x.Body
	}
	return nil
}

func (x *ListResponse) GetMetaHeader() *session.ResponseMetaHeader {
	if x != nil {
		return x.MetaHeader
	}
	return nil
}

func (x *ListResponse) GetVerifyHeader() *session.ResponseVerificationHeader {
	if x != nil {
		return x.VerifyHeader
	}
	return nil
}

// Set Extended ACL
type SetExtendedACLRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Body of set extended acl request message.
	Body *SetExtendedACLRequest_Body `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// Carries request meta information. Header data is used only to regulate
	// message transport and does not affect request execution.
	MetaHeader *session.RequestMetaHeader `protobuf:"bytes,2,opt,name=meta_header,json=metaHeader,proto3" json:"meta_header,omitempty"`
	// Carries request verification information. This header is used to
	// authenticate the nodes of the message route and check the correctness of
	// transmission.
	VerifyHeader  *session.RequestVerificationHeader `protobuf:"bytes,3,opt,name=verify_header,json=verifyHeader,proto3" json:"verify_header,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetExtendedACLRequest) Reset() {
	*x = SetExtendedACLRequest{}
	mi := &file_proto_container_service_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetExtendedACLRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetExtendedACLRequest) ProtoMessage() {}

func (x *SetExtendedACLRequest) ProtoReflect() protoreflect.Message {
	mi := &file_proto_container_service_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetExtendedACLRequest.ProtoReflect.Descriptor instead.
func (*SetExtendedACLRequest) Descriptor() ([]byte, []int) {
	return file_proto_container_service_proto_rawDescGZIP(), []int{8}
}

func (x *SetExtendedACLRequest) GetBody() *SetExtendedACLRequest_Body {
	if x != nil {
		return x.Body
	}
	return nil
}

func (x *SetExtendedACLRequest) GetMetaHeader() *session.RequestMetaHeader {
	if x != nil {
		return x.MetaHeader
	}
	return nil
}

func (x *SetExtendedACLRequest) GetVerifyHeader() *session.RequestVerificationHeader {
	if x != nil {
		return x.VerifyHeader
	}
	return nil
}

// Set Extended ACL
type SetExtendedACLResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Body of set extended acl response message.
	Body *SetExtendedACLResponse_Body `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// Carries response meta information. Header data is used only to regulate
	// message transport and does not affect request execution.
	MetaHeader *session.ResponseMetaHeader `protobuf:"bytes,2,opt,name=meta_header,json=metaHeader,proto3" json:"meta_header,omitempty"`
	// Carries response verification information. This header is used to
	// authenticate the nodes of the message route and check the correctness of
	// transmission.
	VerifyHeader  *session.ResponseVerificationHeader `protobuf:"bytes,3,opt,name=verify_header,json=verifyHeader,proto3" json:"verify_header,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetExtendedACLResponse) Reset() {
	*x = SetExtendedACLResponse{}
	mi := &file_proto_container_service_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetExtendedACLResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetExtendedACLResponse) ProtoMessage() {}

func (x *SetExtendedACLResponse) ProtoReflect() protoreflect.Message {
	mi := &file_proto_container_service_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetExtendedACLResponse.ProtoReflect.Descriptor instead.
func (*SetExtendedACLResponse) Descriptor() ([]byte, []int) {
	return file_proto_container_service_proto_rawDescGZIP(), []int{9}
}

func (x *SetExtendedACLResponse) GetBody() *SetExtendedACLResponse_Body {
	if x != nil {
		return x.Body
	}
	return nil
}

func (x *SetExtendedACLResponse) GetMetaHeader() *session.ResponseMetaHeader {
	if x != nil {
		return x.MetaHeader
	}
	return nil
}

func (x *SetExtendedACLResponse) GetVerifyHeader() *session.ResponseVerificationHeader {
	if x != nil {
		return x.VerifyHeader
	}
	return nil
}

// Get Extended ACL
type GetExtendedACLRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Body of get extended acl request message.
	Body *GetExtendedACLRequest_Body `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// Carries request meta information. Header data is used only to regulate
	// message transport and does not affect request execution.
	MetaHeader *session.RequestMetaHeader `protobuf:"bytes,2,opt,name=meta_header,json=metaHeader,proto3" json:"meta_header,omitempty"`
	// Carries request verification information. This header is used to
	// authenticate the nodes of the message route and check the correctness of
	// transmission.
	VerifyHeader  *session.RequestVerificationHeader `protobuf:"bytes,3,opt,name=verify_header,json=verifyHeader,proto3" json:"verify_header,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetExtendedACLRequest) Reset() {
	*x = GetExtendedACLRequest{}
	mi := &file_proto_container_service_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetExtendedACLRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetExtendedACLRequest) ProtoMessage() {}

func (x *GetExtendedACLRequest) ProtoReflect() protoreflect.Message {
	mi := &file_proto_container_service_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetExtendedACLRequest.ProtoReflect.Descriptor instead.
func (*GetExtendedACLRequest) Descriptor() ([]byte, []int) {
	return file_proto_container_service_proto_rawDescGZIP(), []int{10}
}

func (x *GetExtendedACLRequest) GetBody() *GetExtendedACLRequest_Body {
	if x != nil {
		return x.Body
	}
	return nil
}

func (x *GetExtendedACLRequest) GetMetaHeader() *session.RequestMetaHeader {
	if x != nil {
		return x.MetaHeader
	}
	return nil
}

func (x *GetExtendedACLRequest) GetVerifyHeader() *session.RequestVerificationHeader {
	if x != nil {
		return x.VerifyHeader
	}
	return nil
}

// Get Extended ACL
type GetExtendedACLResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Body of get extended acl response message.
	Body *GetExtendedACLResponse_Body `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// Carries response meta information. Header data is used only to regulate
	// message transport and does not affect request execution.
	MetaHeader *session.ResponseMetaHeader `protobuf:"bytes,2,opt,name=meta_header,json=metaHeader,proto3" json:"meta_header,omitempty"`
	// Carries response verification information. This header is used to
	// authenticate the nodes of the message route and check the correctness of
	// transmission.
	VerifyHeader  *session.ResponseVerificationHeader `protobuf:"bytes,3,opt,name=verify_header,json=verifyHeader,proto3" json:"verify_header,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetExtendedACLResponse) Reset() {
	*x = GetExtendedACLResponse{}
	mi := &file_proto_container_service_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetExtendedACLResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetExtendedACLResponse) ProtoMessage() {}

func (x *GetExtendedACLResponse) ProtoReflect() protoreflect.Message {
	mi := &file_proto_container_service_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetExtendedACLResponse.ProtoReflect.Descriptor instead.
func (*GetExtendedACLResponse) Descriptor() ([]byte, []int) {
	return file_proto_container_service_proto_rawDescGZIP(), []int{11}
}

func (x *GetExtendedACLResponse) GetBody() *GetExtendedACLResponse_Body {
	if x != nil {
		return x.Body
	}
	return nil
}

func (x *GetExtendedACLResponse) GetMetaHeader() *session.ResponseMetaHeader {
	if x != nil {
		return x.MetaHeader
	}
	return nil
}

func (x *GetExtendedACLResponse) GetVerifyHeader() *session.ResponseVerificationHeader {
	if x != nil {
		return x.VerifyHeader
	}
	return nil
}

// Announce container used space
//
// DEPRECATED: every storage node must send storage load directly to `container`
// contract.
type AnnounceUsedSpaceRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Body of announce used space request message.
	Body *AnnounceUsedSpaceRequest_Body `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// Carries request meta information. Header data is used only to regulate
	// message transport and does not affect request execution.
	MetaHeader *session.RequestMetaHeader `protobuf:"bytes,2,opt,name=meta_header,json=metaHeader,proto3" json:"meta_header,omitempty"`
	// Carries request verification information. This header is used to
	// authenticate the nodes of the message route and check the correctness of
	// transmission.
	VerifyHeader  *session.RequestVerificationHeader `protobuf:"bytes,3,opt,name=verify_header,json=verifyHeader,proto3" json:"verify_header,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AnnounceUsedSpaceRequest) Reset() {
	*x = AnnounceUsedSpaceRequest{}
	mi := &file_proto_container_service_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AnnounceUsedSpaceRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AnnounceUsedSpaceRequest) ProtoMessage() {}

func (x *AnnounceUsedSpaceRequest) ProtoReflect() protoreflect.Message {
	mi := &file_proto_container_service_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AnnounceUsedSpaceRequest.ProtoReflect.Descriptor instead.
func (*AnnounceUsedSpaceRequest) Descriptor() ([]byte, []int) {
	return file_proto_container_service_proto_rawDescGZIP(), []int{12}
}

func (x *AnnounceUsedSpaceRequest) GetBody() *AnnounceUsedSpaceRequest_Body {
	if x != nil {
		return x.Body
	}
	return nil
}

func (x *AnnounceUsedSpaceRequest) GetMetaHeader() *session.RequestMetaHeader {
	if x != nil {
		return x.MetaHeader
	}
	return nil
}

func (x *AnnounceUsedSpaceRequest) GetVerifyHeader() *session.RequestVerificationHeader {
	if x != nil {
		return x.VerifyHeader
	}
	return nil
}

// Announce container used space
//
// DEPRECATED: every storage node must send storage load directly to `container`
// contract.
type AnnounceUsedSpaceResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Body of announce used space response message.
	Body *AnnounceUsedSpaceResponse_Body `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// Carries response meta information. Header data is used only to regulate
	// message transport and does not affect request execution.
	MetaHeader *session.ResponseMetaHeader `protobuf:"bytes,2,opt,name=meta_header,json=metaHeader,proto3" json:"meta_header,omitempty"`
	// Carries response verification information. This header is used to
	// authenticate the nodes of the message route and check the correctness of
	// transmission.
	VerifyHeader  *session.ResponseVerificationHeader `protobuf:"bytes,3,opt,name=verify_header,json=verifyHeader,proto3" json:"verify_header,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AnnounceUsedSpaceResponse) Reset() {
	*x = AnnounceUsedSpaceResponse{}
	mi := &file_proto_container_service_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AnnounceUsedSpaceResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AnnounceUsedSpaceResponse) ProtoMessage() {}

func (x *AnnounceUsedSpaceResponse) ProtoReflect() protoreflect.Message {
	mi := &file_proto_container_service_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AnnounceUsedSpaceResponse.ProtoReflect.Descriptor instead.
func (*AnnounceUsedSpaceResponse) Descriptor() ([]byte, []int) {
	return file_proto_container_service_proto_rawDescGZIP(), []int{13}
}

func (x *AnnounceUsedSpaceResponse) GetBody() *AnnounceUsedSpaceResponse_Body {
	if x != nil {
		return x.Body
	}
	return nil
}

func (x *AnnounceUsedSpaceResponse) GetMetaHeader() *session.ResponseMetaHeader {
	if x != nil {
		return x.MetaHeader
	}
	return nil
}

func (x *AnnounceUsedSpaceResponse) GetVerifyHeader() *session.ResponseVerificationHeader {
	if x != nil {
		return x.VerifyHeader
	}
	return nil
}

// Attribute setting request
type SetAttributeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Request payload.
	Body *SetAttributeRequest_Body `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// Signature of stable-marshalled `body` field.
	BodySignature *refs.Signature `protobuf:"bytes,2,opt,name=body_signature,json=bodySignature,proto3" json:"body_signature,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetAttributeRequest) Reset() {
	*x = SetAttributeRequest{}
	mi := &file_proto_container_service_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetAttributeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetAttributeRequest) ProtoMessage() {}

func (x *SetAttributeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_proto_container_service_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetAttributeRequest.ProtoReflect.Descriptor instead.
func (*SetAttributeRequest) Descriptor() ([]byte, []int) {
	return file_proto_container_service_proto_rawDescGZIP(), []int{14}
}

func (x *SetAttributeRequest) GetBody() *SetAttributeRequest_Body {
	if x != nil {
		return x.Body
	}
	return nil
}

func (x *SetAttributeRequest) GetBodySignature() *refs.Signature {
	if x != nil {
		return x.BodySignature
	}
	return nil
}

// Attribute setting response
type SetAttributeResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Operation execution status.
	Status        *status.Status `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetAttributeResponse) Reset() {
	*x = SetAttributeResponse{}
	mi := &file_proto_container_service_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetAttributeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetAttributeResponse) ProtoMessage() {}

func (x *SetAttributeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_proto_container_service_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetAttributeResponse.ProtoReflect.Descriptor instead.
func (*SetAttributeResponse) Descriptor() ([]byte, []int) {
	return file_proto_container_service_proto_rawDescGZIP(), []int{15}
}

func (x *SetAttributeResponse) GetStatus() *status.Status {
	if x != nil {
		return x.Status
	}
	return nil
}

// Attribute removal request
type RemoveAttributeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Request payload.
	Body *RemoveAttributeRequest_Body `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// Signature of stable-marshalled `body` field.
	BodySignature *refs.Signature `protobuf:"bytes,2,opt,name=body_signature,json=bodySignature,proto3" json:"body_signature,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RemoveAttributeRequest) Reset() {
	*x = RemoveAttributeRequest{}
	mi := &file_proto_container_service_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RemoveAttributeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemoveAttributeRequest) ProtoMessage() {}

func (x *RemoveAttributeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_proto_container_service_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RemoveAttributeRequest.ProtoReflect.Descriptor instead.
func (*RemoveAttributeRequest) Descriptor() ([]byte, []int) {
	return file_proto_container_service_proto_rawDescGZIP(), []int{16}
}

func (x *RemoveAttributeRequest) GetBody() *RemoveAttributeRequest_Body {
	if x != nil {
		return x.Body
	}
	return nil
}

func (x *RemoveAttributeRequest) GetBodySignature() *refs.Signature {
	if x != nil {
		return x.BodySignature
	}
	return nil
}

// Attribute removal response
type RemoveAttributeResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Operation execution status.
	Status        *status.Status `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RemoveAttributeResponse) Reset() {
	*x = RemoveAttributeResponse{}
	mi := &file_proto_container_service_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RemoveAttributeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemoveAttributeResponse) ProtoMessage() {}

func (x *RemoveAttributeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_proto_container_service_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RemoveAttributeResponse.ProtoReflect.Descriptor instead.
func (*RemoveAttributeResponse) Descriptor() ([]byte, []int) {
	return file_proto_container_service_proto_rawDescGZIP(), []int{17}
}

func (x *RemoveAttributeResponse) GetStatus() *status.Status {
	if x != nil {
		return x.Status
	}
	return nil
}

// Container creation request has container structure's signature as a
// separate field. It's not stored in FS chain, just verified on container
// creation by `Container` smart contract. `ContainerID` is a SHA256 hash of
// the stable-marshalled container strucutre, hence there is no need for
// additional signature checks.
type PutRequest_Body struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Container structure to register in NeoFS
	Container *Container `protobuf:"bytes,1,opt,name=container,proto3" json:"container,omitempty"`
	// Signature of a stable-marshalled container according to RFC-6979.
	Signature     *refs.SignatureRFC6979 `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PutRequest_Body) Reset() {
	*x = PutRequest_Body{}
	mi := &file_proto_container_service_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PutRequest_Body) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PutRequest_Body) ProtoMessage() {}

func (x *PutRequest_Body) ProtoReflect() protoreflect.Message {
	mi := &file_proto_container_service_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PutRequest_Body.ProtoReflect.Descriptor instead.
func (*PutRequest_Body) Descriptor() ([]byte, []int) {
	return file_proto_container_service_proto_rawDescGZIP(), []int{0, 0}
}

func (x *PutRequest_Body) GetContainer() *Container {
	if x != nil {
		return x.Container
	}
	return nil
}

func (x *PutRequest_Body) GetSignature() *refs.SignatureRFC6979 {
	if x != nil {
		return x.Signature
	}
	return nil
}

// Container put response body contains information about the newly registered
// container as seen by `Container` smart contract. `ContainerID` can be
// calculated beforehand from the container structure and compared to the one
// returned here to make sure everything has been done as expected.
type PutResponse_Body struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique identifier of the newly created container
	ContainerId   *refs.ContainerID `protobuf:"bytes,1,opt,name=container_id,json=containerId,proto3" json:"container_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PutResponse_Body) Reset() {
	*x = PutResponse_Body{}
	mi := &file_proto_container_service_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PutResponse_Body) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PutResponse_Body) ProtoMessage() {}

func (x *PutResponse_Body) ProtoReflect() protoreflect.Message {
	mi := &file_proto_container_service_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PutResponse_Body.ProtoReflect.Descriptor instead.
func (*PutResponse_Body) Descriptor() ([]byte, []int) {
	return file_proto_container_service_proto_rawDescGZIP(), []int{1, 0}
}

func (x *PutResponse_Body) GetContainerId() *refs.ContainerID {
	if x != nil {
		return x.ContainerId
	}
	return nil
}

// Container removal request body has signed `ContainerID` as a proof of
// the container owner's intent. The signature will be verified by `Container`
// smart contract, so signing algorithm must be supported by NeoVM.
type DeleteRequest_Body struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Identifier of the container to delete from NeoFS
	ContainerId *refs.ContainerID `protobuf:"bytes,1,opt,name=container_id,json=containerId,proto3" json:"container_id,omitempty"`
	// `ContainerID` signed with the container owner's key according to RFC-6979.
	Signature     *refs.SignatureRFC6979 `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteRequest_Body) Reset() {
	*x = DeleteRequest_Body{}
	mi := &file_proto_container_service_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteRequest_Body) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteRequest_Body) ProtoMessage() {}

func (x *DeleteRequest_Body) ProtoReflect() protoreflect.Message {
	mi := &file_proto_container_service_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteRequest_Body.ProtoReflect.Descriptor instead.
func (*DeleteRequest_Body) Descriptor() ([]byte, []int) {
	return file_proto_container_service_proto_rawDescGZIP(), []int{2, 0}
}

func (x *DeleteRequest_Body) GetContainerId() *refs.ContainerID {
	if x != nil {
		return x.ContainerId
	}
	return nil
}

func (x *DeleteRequest_Body) GetSignature() *refs.SignatureRFC6979 {
	if x != nil {
		return x.Signature
	}
	return nil
}

// `DeleteResponse` has an empty body because delete operation is asynchronous
// and done via consensus in Inner Ring nodes.
type DeleteResponse_Body struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteResponse_Body) Reset() {
	*x = DeleteResponse_Body{}
	mi := &file_proto_container_service_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteResponse_Body) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteResponse_Body) ProtoMessage() {}

func (x *DeleteResponse_Body) ProtoReflect() protoreflect.Message {
	mi := &file_proto_container_service_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteResponse_Body.ProtoReflect.Descriptor instead.
func (*DeleteResponse_Body) Descriptor() ([]byte, []int) {
	return file_proto_container_service_proto_rawDescGZIP(), []int{3, 0}
}

// Get container structure request body.
type GetRequest_Body struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Identifier of the container to get
	ContainerId   *refs.ContainerID `protobuf:"bytes,1,opt,name=container_id,json=containerId,proto3" json:"container_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetRequest_Body) Reset() {
	*x = GetRequest_Body{}
	mi := &file_proto_container_service_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetRequest_Body) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRequest_Body) ProtoMessage() {}

func (x *GetRequest_Body) ProtoReflect() protoreflect.Message {
	mi := &file_proto_container_service_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRequest_Body.ProtoReflect.Descriptor instead.
func (*GetRequest_Body) Descriptor() ([]byte, []int) {
	return file_proto_container_service_proto_rawDescGZIP(), []int{4, 0}
}

func (x *GetRequest_Body) GetContainerId() *refs.ContainerID {
	if x != nil {
		return x.ContainerId
	}
	return nil
}

// Get container response body does not have container structure signature. It
// has been already verified upon container creation.
type GetResponse_Body struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Requested container structure
	Container *Container `protobuf:"bytes,1,opt,name=container,proto3" json:"container,omitempty"`
	// Signature of a stable-marshalled container according to RFC-6979.
	Signature *refs.SignatureRFC6979 `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	// Session token if the container has been created within the session
	SessionToken  *session.SessionToken `protobuf:"bytes,3,opt,name=session_token,json=sessionToken,proto3" json:"session_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetResponse_Body) Reset() {
	*x = GetResponse_Body{}
	mi := &file_proto_container_service_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetResponse_Body) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetResponse_Body) ProtoMessage() {}

func (x *GetResponse_Body) ProtoReflect() protoreflect.Message {
	mi := &file_proto_container_service_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetResponse_Body.ProtoReflect.Descriptor instead.
func (*GetResponse_Body) Descriptor() ([]byte, []int) {
	return file_proto_container_service_proto_rawDescGZIP(), []int{5, 0}
}

func (x *GetResponse_Body) GetContainer() *Container {
	if x != nil {
		return x.Container
	}
	return nil
}

func (x *GetResponse_Body) GetSignature() *refs.SignatureRFC6979 {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *GetResponse_Body) GetSessionToken() *session.SessionToken {
	if x != nil {
		return x.SessionToken
	}
	return nil
}

// List containers request body.
type ListRequest_Body struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Identifier of the container owner
	OwnerId       *refs.OwnerID `protobuf:"bytes,1,opt,name=owner_id,json=ownerId,proto3" json:"owner_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListRequest_Body) Reset() {
	*x = ListRequest_Body{}
	mi := &file_proto_container_service_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListRequest_Body) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListRequest_Body) ProtoMessage() {}

func (x *ListRequest_Body) ProtoReflect() protoreflect.Message {
	mi := &file_proto_container_service_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListRequest_Body.ProtoReflect.Descriptor instead.
func (*ListRequest_Body) Descriptor() ([]byte, []int) {
	return file_proto_container_service_proto_rawDescGZIP(), []int{6, 0}
}

func (x *ListRequest_Body) GetOwnerId() *refs.OwnerID {
	if x != nil {
		return x.OwnerId
	}
	return nil
}

// List containers response body.
type ListResponse_Body struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of `ContainerID`s belonging to the requested `OwnerID`
	ContainerIds  []*refs.ContainerID `protobuf:"bytes,1,rep,name=container_ids,json=containerIds,proto3" json:"container_ids,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListResponse_Body) Reset() {
	*x = ListResponse_Body{}
	mi := &file_proto_container_service_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListResponse_Body) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListResponse_Body) ProtoMessage() {}

func (x *ListResponse_Body) ProtoReflect() protoreflect.Message {
	mi := &file_proto_container_service_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListResponse_Body.ProtoReflect.Descriptor instead.
func (*ListResponse_Body) Descriptor() ([]byte, []int) {
	return file_proto_container_service_proto_rawDescGZIP(), []int{7, 0}
}

func (x *ListResponse_Body) GetContainerIds() []*refs.ContainerID {
	if x != nil {
		return x.ContainerIds
	}
	return nil
}

// Set Extended ACL request body does not have separate `ContainerID`
// reference. It will be taken from `EACLTable.container_id` field.
type SetExtendedACLRequest_Body struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Extended ACL table to set for the container
	Eacl *acl.EACLTable `protobuf:"bytes,1,opt,name=eacl,proto3" json:"eacl,omitempty"`
	// Signature of stable-marshalled Extended ACL table according to RFC-6979.
	Signature     *refs.SignatureRFC6979 `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetExtendedACLRequest_Body) Reset() {
	*x = SetExtendedACLRequest_Body{}
	mi := &file_proto_container_service_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetExtendedACLRequest_Body) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetExtendedACLRequest_Body) ProtoMessage() {}

func (x *SetExtendedACLRequest_Body) ProtoReflect() protoreflect.Message {
	mi := &file_proto_container_service_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetExtendedACLRequest_Body.ProtoReflect.Descriptor instead.
func (*SetExtendedACLRequest_Body) Descriptor() ([]byte, []int) {
	return file_proto_container_service_proto_rawDescGZIP(), []int{8, 0}
}

func (x *SetExtendedACLRequest_Body) GetEacl() *acl.EACLTable {
	if x != nil {
		return x.Eacl
	}
	return nil
}

func (x *SetExtendedACLRequest_Body) GetSignature() *refs.SignatureRFC6979 {
	if x != nil {
		return x.Signature
	}
	return nil
}

// `SetExtendedACLResponse` has an empty body because the operation is
// asynchronous and the update should be reflected in `Container` smart contract's
// storage after next block is issued in FS chain.
type SetExtendedACLResponse_Body struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetExtendedACLResponse_Body) Reset() {
	*x = SetExtendedACLResponse_Body{}
	mi := &file_proto_container_service_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetExtendedACLResponse_Body) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetExtendedACLResponse_Body) ProtoMessage() {}

func (x *SetExtendedACLResponse_Body) ProtoReflect() protoreflect.Message {
	mi := &file_proto_container_service_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetExtendedACLResponse_Body.ProtoReflect.Descriptor instead.
func (*SetExtendedACLResponse_Body) Descriptor() ([]byte, []int) {
	return file_proto_container_service_proto_rawDescGZIP(), []int{9, 0}
}

// Get Extended ACL request body
type GetExtendedACLRequest_Body struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Identifier of the container having Extended ACL
	ContainerId   *refs.ContainerID `protobuf:"bytes,1,opt,name=container_id,json=containerId,proto3" json:"container_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetExtendedACLRequest_Body) Reset() {
	*x = GetExtendedACLRequest_Body{}
	mi := &file_proto_container_service_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetExtendedACLRequest_Body) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetExtendedACLRequest_Body) ProtoMessage() {}

func (x *GetExtendedACLRequest_Body) ProtoReflect() protoreflect.Message {
	mi := &file_proto_container_service_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetExtendedACLRequest_Body.ProtoReflect.Descriptor instead.
func (*GetExtendedACLRequest_Body) Descriptor() ([]byte, []int) {
	return file_proto_container_service_proto_rawDescGZIP(), []int{10, 0}
}

func (x *GetExtendedACLRequest_Body) GetContainerId() *refs.ContainerID {
	if x != nil {
		return x.ContainerId
	}
	return nil
}

// Get Extended ACL Response body can be empty if the requested container does
// not have Extended ACL Table attached or Extended ACL has not been allowed at
// the time of container creation.
type GetExtendedACLResponse_Body struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Extended ACL requested, if available
	Eacl *acl.EACLTable `protobuf:"bytes,1,opt,name=eacl,proto3" json:"eacl,omitempty"`
	// Signature of stable-marshalled Extended ACL according to RFC-6979.
	Signature *refs.SignatureRFC6979 `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	// Session token if Extended ACL was set within a session
	SessionToken  *session.SessionToken `protobuf:"bytes,3,opt,name=session_token,json=sessionToken,proto3" json:"session_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetExtendedACLResponse_Body) Reset() {
	*x = GetExtendedACLResponse_Body{}
	mi := &file_proto_container_service_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetExtendedACLResponse_Body) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetExtendedACLResponse_Body) ProtoMessage() {}

func (x *GetExtendedACLResponse_Body) ProtoReflect() protoreflect.Message {
	mi := &file_proto_container_service_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetExtendedACLResponse_Body.ProtoReflect.Descriptor instead.
func (*GetExtendedACLResponse_Body) Descriptor() ([]byte, []int) {
	return file_proto_container_service_proto_rawDescGZIP(), []int{11, 0}
}

func (x *GetExtendedACLResponse_Body) GetEacl() *acl.EACLTable {
	if x != nil {
		return x.Eacl
	}
	return nil
}

func (x *GetExtendedACLResponse_Body) GetSignature() *refs.SignatureRFC6979 {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *GetExtendedACLResponse_Body) GetSessionToken() *session.SessionToken {
	if x != nil {
		return x.SessionToken
	}
	return nil
}

// Container used space announcement body.
type AnnounceUsedSpaceRequest_Body struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of announcements. If nodes share several containers,
	// announcements are transferred in a batch.
	Announcements []*AnnounceUsedSpaceRequest_Body_Announcement `protobuf:"bytes,1,rep,name=announcements,proto3" json:"announcements,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AnnounceUsedSpaceRequest_Body) Reset() {
	*x = AnnounceUsedSpaceRequest_Body{}
	mi := &file_proto_container_service_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AnnounceUsedSpaceRequest_Body) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AnnounceUsedSpaceRequest_Body) ProtoMessage() {}

func (x *AnnounceUsedSpaceRequest_Body) ProtoReflect() protoreflect.Message {
	mi := &file_proto_container_service_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AnnounceUsedSpaceRequest_Body.ProtoReflect.Descriptor instead.
func (*AnnounceUsedSpaceRequest_Body) Descriptor() ([]byte, []int) {
	return file_proto_container_service_proto_rawDescGZIP(), []int{12, 0}
}

func (x *AnnounceUsedSpaceRequest_Body) GetAnnouncements() []*AnnounceUsedSpaceRequest_Body_Announcement {
	if x != nil {
		return x.Announcements
	}
	return nil
}

// Announcement contains used space information for a single container.
type AnnounceUsedSpaceRequest_Body_Announcement struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Epoch number for which the container size estimation was produced.
	Epoch uint64 `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	// Identifier of the container.
	ContainerId *refs.ContainerID `protobuf:"bytes,2,opt,name=container_id,json=containerId,proto3" json:"container_id,omitempty"`
	// Used space is a sum of object payload sizes of a specified
	// container, stored in the node. It must not include inhumed objects.
	UsedSpace     uint64 `protobuf:"varint,3,opt,name=used_space,json=usedSpace,proto3" json:"used_space,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AnnounceUsedSpaceRequest_Body_Announcement) Reset() {
	*x = AnnounceUsedSpaceRequest_Body_Announcement{}
	mi := &file_proto_container_service_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AnnounceUsedSpaceRequest_Body_Announcement) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AnnounceUsedSpaceRequest_Body_Announcement) ProtoMessage() {}

func (x *AnnounceUsedSpaceRequest_Body_Announcement) ProtoReflect() protoreflect.Message {
	mi := &file_proto_container_service_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AnnounceUsedSpaceRequest_Body_Announcement.ProtoReflect.Descriptor instead.
func (*AnnounceUsedSpaceRequest_Body_Announcement) Descriptor() ([]byte, []int) {
	return file_proto_container_service_proto_rawDescGZIP(), []int{12, 0, 0}
}

func (x *AnnounceUsedSpaceRequest_Body_Announcement) GetEpoch() uint64 {
	if x != nil {
		return x.Epoch
	}
	return 0
}

func (x *AnnounceUsedSpaceRequest_Body_Announcement) GetContainerId() *refs.ContainerID {
	if x != nil {
		return x.ContainerId
	}
	return nil
}

func (x *AnnounceUsedSpaceRequest_Body_Announcement) GetUsedSpace() uint64 {
	if x != nil {
		return x.UsedSpace
	}
	return 0
}

// `AnnounceUsedSpaceResponse` has an empty body because announcements are
// one way communication.
type AnnounceUsedSpaceResponse_Body struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AnnounceUsedSpaceResponse_Body) Reset() {
	*x = AnnounceUsedSpaceResponse_Body{}
	mi := &file_proto_container_service_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AnnounceUsedSpaceResponse_Body) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AnnounceUsedSpaceResponse_Body) ProtoMessage() {}

func (x *AnnounceUsedSpaceResponse_Body) ProtoReflect() protoreflect.Message {
	mi := &file_proto_container_service_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AnnounceUsedSpaceResponse_Body.ProtoReflect.Descriptor instead.
func (*AnnounceUsedSpaceResponse_Body) Descriptor() ([]byte, []int) {
	return file_proto_container_service_proto_rawDescGZIP(), []int{13, 0}
}

// Request payload message.
type SetAttributeRequest_Body struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Op parameters.
	Parameters *SetAttributeRequest_Body_Parameters `protobuf:"bytes,1,opt,name=parameters,proto3" json:"parameters,omitempty"`
	// N3 witness of stable-marshalled `parameters` field. The
	// signature must authenticate either container owner or one of subjects in
	// the `session_token` field if any. Signature according to
	// `ECDSA_RFC6979_SHA256` scheme is also supported.
	Signature *refs.SignatureRFC6979 `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	// Optional session token. The token must be issued by the container owner.
	// The token must have at least one subject authenticated by `signature`
	// field. The token must have at least one context with this container and
	// `CONTAINER_SETATTRIBUTE` verb.
	SessionToken *session.SessionTokenV2 `protobuf:"bytes,3,opt,name=session_token,json=sessionToken,proto3" json:"session_token,omitempty"`
	// Optional session token (V1). It must not be set together with
	// `session_token` field that is highly recommended to be used instead.
	// Requirements are the same for both.
	SessionTokenV1 *session.SessionToken `protobuf:"bytes,4,opt,name=session_token_v1,json=sessionTokenV1,proto3" json:"session_token_v1,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *SetAttributeRequest_Body) Reset() {
	*x = SetAttributeRequest_Body{}
	mi := &file_proto_container_service_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetAttributeRequest_Body) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetAttributeRequest_Body) ProtoMessage() {}

func (x *SetAttributeRequest_Body) ProtoReflect() protoreflect.Message {
	mi := &file_proto_container_service_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetAttributeRequest_Body.ProtoReflect.Descriptor instead.
func (*SetAttributeRequest_Body) Descriptor() ([]byte, []int) {
	return file_proto_container_service_proto_rawDescGZIP(), []int{14, 0}
}

func (x *SetAttributeRequest_Body) GetParameters() *SetAttributeRequest_Body_Parameters {
	if x != nil {
		return x.Parameters
	}
	return nil
}

func (x *SetAttributeRequest_Body) GetSignature() *refs.SignatureRFC6979 {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *SetAttributeRequest_Body) GetSessionToken() *session.SessionTokenV2 {
	if x != nil {
		return x.SessionToken
	}
	return nil
}

func (x *SetAttributeRequest_Body) GetSessionTokenV1() *session.SessionToken {
	if x != nil {
		return x.SessionTokenV1
	}
	return nil
}

// Op parameters message.
//
// If container does not have the `attribute`, it is added. Otherwise, its
// value is swapped.
//
// `valid_until` is required request expiration time in Unix Timestamp
// format.
//
// `attribute` must be one of:
//   - `CORS`;
//   - `S3_TAGS`;
//   - `S3_SETTINGS`;
//   - `S3_NOTIFICATIONS`;
//   - `__NEOFS__LOCK_UNTIL`.
//
// In general, requirements for `value` are the same as for container
// creation. Attribute-specific requirements:
//   - `__NEOFS__LOCK_UNTIL`: new timestamp must be after the current one if any
//   - `S3_TAGS`: must be a valid JSON object
//   - `S3_SETTINGS`: must be a valid JSON object
//   - `S3_NOTIFICATIONS`: must be a valid JSON object
type SetAttributeRequest_Body_Parameters struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Identifier of the container to set attribute for.
	ContainerId *refs.ContainerID `protobuf:"bytes,1,opt,name=container_id,json=containerId,proto3" json:"container_id,omitempty"`
	// Attribute to be set.
	Attribute string `protobuf:"bytes,2,opt,name=attribute,proto3" json:"attribute,omitempty"`
	// New attribute value.
	Value string `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	// Request expiration time.
	ValidUntil    uint64 `protobuf:"varint,4,opt,name=valid_until,json=validUntil,proto3" json:"valid_until,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetAttributeRequest_Body_Parameters) Reset() {
	*x = SetAttributeRequest_Body_Parameters{}
	mi := &file_proto_container_service_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetAttributeRequest_Body_Parameters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetAttributeRequest_Body_Parameters) ProtoMessage() {}

func (x *SetAttributeRequest_Body_Parameters) ProtoReflect() protoreflect.Message {
	mi := &file_proto_container_service_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetAttributeRequest_Body_Parameters.ProtoReflect.Descriptor instead.
func (*SetAttributeRequest_Body_Parameters) Descriptor() ([]byte, []int) {
	return file_proto_container_service_proto_rawDescGZIP(), []int{14, 0, 0}
}

func (x *SetAttributeRequest_Body_Parameters) GetContainerId() *refs.ContainerID {
	if x != nil {
		return x.ContainerId
	}
	return nil
}

func (x *SetAttributeRequest_Body_Parameters) GetAttribute() string {
	if x != nil {
		return x.Attribute
	}
	return ""
}

func (x *SetAttributeRequest_Body_Parameters) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

func (x *SetAttributeRequest_Body_Parameters) GetValidUntil() uint64 {
	if x != nil {
		return x.ValidUntil
	}
	return 0
}

// Request payload message.
type RemoveAttributeRequest_Body struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Op parameters.
	Parameters *RemoveAttributeRequest_Body_Parameters `protobuf:"bytes,1,opt,name=parameters,proto3" json:"parameters,omitempty"`
	// N3 witness of stable-marshalled `parameters` field. The
	// signature must authenticate either container owner or one of subjects in
	// the `session_token` field if any. Signature according to
	// `ECDSA_RFC6979_SHA256` scheme is also supported.
	Signature *refs.SignatureRFC6979 `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	// Optional session token. The token must be issued by the container owner.
	// The token must have at least one subject authenticated by `signature`
	// field. The token must have at least one context with this container and
	// `CONTAINER_REMOVEATTRIBUTE` verb.
	SessionToken *session.SessionTokenV2 `protobuf:"bytes,3,opt,name=session_token,json=sessionToken,proto3" json:"session_token,omitempty"`
	// Optional session token (V1). It must not be set together with
	// `session_token` field that is highly recommended to be used instead.
	// Requirements are the same for both.
	SessionTokenV1 *session.SessionToken `protobuf:"bytes,4,opt,name=session_token_v1,json=sessionTokenV1,proto3" json:"session_token_v1,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *RemoveAttributeRequest_Body) Reset() {
	*x = RemoveAttributeRequest_Body{}
	mi := &file_proto_container_service_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RemoveAttributeRequest_Body) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemoveAttributeRequest_Body) ProtoMessage() {}

func (x *RemoveAttributeRequest_Body) ProtoReflect() protoreflect.Message {
	mi := &file_proto_container_service_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RemoveAttributeRequest_Body.ProtoReflect.Descriptor instead.
func (*RemoveAttributeRequest_Body) Descriptor() ([]byte, []int) {
	return file_proto_container_service_proto_rawDescGZIP(), []int{16, 0}
}

func (x *RemoveAttributeRequest_Body) GetParameters() *RemoveAttributeRequest_Body_Parameters {
	if x != nil {
		return x.Parameters
	}
	return nil
}

func (x *RemoveAttributeRequest_Body) GetSignature() *refs.SignatureRFC6979 {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *RemoveAttributeRequest_Body) GetSessionToken() *session.SessionTokenV2 {
	if x != nil {
		return x.SessionToken
	}
	return nil
}

func (x *RemoveAttributeRequest_Body) GetSessionTokenV1() *session.SessionToken {
	if x != nil {
		return x.SessionTokenV1
	}
	return nil
}

// Op parameters message.
//
// If container does not have the `attribute`, nothing is done and status
// `OK` is returned.
//
// `valid_until` is required request expiration time in Unix Timestamp
// format.
//
// `attribute` must be one of:
//   - `CORS`;
//   - `S3_TAGS`;
//   - `S3_SETTINGS`;
//   - `S3_NOTIFICATIONS`;
//   - `__NEOFS__LOCK_UNTIL`.
//
// Attribute-specific requirements:
//   - `__NEOFS__LOCK_UNTIL`: current timestamp must have already passed if any
type RemoveAttributeRequest_Body_Parameters struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Identifier of the container to remove attribute from.
	ContainerId *refs.ContainerID `protobuf:"bytes,1,opt,name=container_id,json=containerId,proto3" json:"container_id,omitempty"`
	// Attribute to be removed.
	Attribute string `protobuf:"bytes,2,opt,name=attribute,proto3" json:"attribute,omitempty"`
	// Request expiration time.
	ValidUntil    uint64 `protobuf:"varint,3,opt,name=valid_until,json=validUntil,proto3" json:"valid_until,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RemoveAttributeRequest_Body_Parameters) Reset() {
	*x = RemoveAttributeRequest_Body_Parameters{}
	mi := &file_proto_container_service_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RemoveAttributeRequest_Body_Parameters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemoveAttributeRequest_Body_Parameters) ProtoMessage() {}

func (x *RemoveAttributeRequest_Body_Parameters) ProtoReflect() protoreflect.Message {
	mi := &file_proto_container_service_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RemoveAttributeRequest_Body_Parameters.ProtoReflect.Descriptor instead.
func (*RemoveAttributeRequest_Body_Parameters) Descriptor() ([]byte, []int) {
	return file_proto_container_service_proto_rawDescGZIP(), []int{16, 0, 0}
}

func (x *RemoveAttributeRequest_Body_Parameters) GetContainerId() *refs.ContainerID {
	if x != nil {
		return x.ContainerId
	}
	return nil
}

func (x *RemoveAttributeRequest_Body_Parameters) GetAttribute() string {
	if x != nil {
		return x.Attribute
	}
	return ""
}

func (x *RemoveAttributeRequest_Body_Parameters) GetValidUntil() uint64 {
	if x != nil {
		return x.ValidUntil
	}
	return 0
}

var File_proto_container_service_proto protoreflect.FileDescriptor

const file_proto_container_service_proto_rawDesc = "" +
	"\n" +
	"\x1dproto/container/service.proto\x12\x13neo.fs.v2.container\x1a\x15proto/acl/types.proto\x1a\x1bproto/container/types.proto\x1a\x16proto/refs/types.proto\x1a\x19proto/session/types.proto\x1a\x18proto/status/types.proto\"\xe7\x02\n" +
	"\n" +
	"PutRequest\x128\n" +
	"\x04body\x18\x01 \x01(\v2$.neo.fs.v2.container.PutRequest.BodyR\x04body\x12E\n" +
	"\vmeta_header\x18\x02 \x01(\v2$.neo.fs.v2.session.RequestMetaHeaderR\n" +
	"metaHeader\x12Q\n" +
	"\rverify_header\x18\x03 \x01(\v2,.neo.fs.v2.session.RequestVerificationHeaderR\fverifyHeader\x1a\x84\x01\n" +
	"\x04Body\x12<\n" +
	"\tcontainer\x18\x01 \x01(\v2\x1e.neo.fs.v2.container.ContainerR\tcontainer\x12>\n" +
	"\tsignature\x18\x02 \x01(\v2 .neo.fs.v2.refs.SignatureRFC6979R\tsignature\"\xac\x02\n" +
	"\vPutResponse\x129\n" +
	"\x04body\x18\x01 \x01(\v2%.neo.fs.v2.container.PutResponse.BodyR\x04body\x12F\n" +
	"\vmeta_header\x18\x02 \x01(\v2%.neo.fs.v2.session.ResponseMetaHeaderR\n" +
	"metaHeader\x12R\n" +
	"\rverify_header\x18\x03 \x01(\v2-.neo.fs.v2.session.ResponseVerificationHeaderR\fverifyHeader\x1aF\n" +
	"\x04Body\x12>\n" +
	"\fcontainer_id\x18\x01 \x01(\v2\x1b.neo.fs.v2.refs.ContainerIDR\vcontainerId\"\xef\x02\n" +
	"\rDeleteRequest\x12;\n" +
	"\x04body\x18\x01 \x01(\v2'.neo.fs.v2.container.DeleteRequest.BodyR\x04body\x12E\n" +
	"\vmeta_header\x18\x02 \x01(\v2$.neo.fs.v2.session.RequestMetaHeaderR\n" +
	"metaHeader\x12Q\n" +
	"\rverify_header\x18\x03 \x01(\v2,.neo.fs.v2.session.RequestVerificationHeaderR\fverifyHeader\x1a\x86\x01\n" +
	"\x04Body\x12>\n" +
	"\fcontainer_id\x18\x01 \x01(\v2\x1b.neo.fs.v2.refs.ContainerIDR\vcontainerId\x12>\n" +
	"\tsignature\x18\x02 \x01(\v2 .neo.fs.v2.refs.SignatureRFC6979R\tsignature\"\xf2\x01\n" +
	"\x0eDeleteResponse\x12<\n" +
	"\x04body\x18\x01 \x01(\v2(.neo.fs.v2.container.DeleteResponse.BodyR\x04body\x12F\n" +
	"\vmeta_header\x18\x02 \x01(\v2%.neo.fs.v2.session.ResponseMetaHeaderR\n" +
	"metaHeader\x12R\n" +
	"\rverify_header\x18\x03 \x01(\v2-.neo.fs.v2.session.ResponseVerificationHeaderR\fverifyHeader\x1a\x06\n" +
	"\x04Body\"\xa8\x02\n" +
	"\n" +
	"GetRequest\x128\n" +
	"\x04body\x18\x01 \x01(\v2$.neo.fs.v2.container.GetRequest.BodyR\x04body\x12E\n" +
	"\vmeta_header\x18\x02 \x01(\v2$.neo.fs.v2.session.RequestMetaHeaderR\n" +
	"metaHeader\x12Q\n" +
	"\rverify_header\x18\x03 \x01(\v2,.neo.fs.v2.session.RequestVerificationHeaderR\fverifyHeader\x1aF\n" +
	"\x04Body\x12>\n" +
	"\fcontainer_id\x18\x01 \x01(\v2\x1b.neo.fs.v2.refs.ContainerIDR\vcontainerId\"\xb1\x03\n" +
	"\vGetResponse\x129\n" +
	"\x04body\x18\x01 \x01(\v2%.neo.fs.v2.container.GetResponse.BodyR\x04body\x12F\n" +
	"\vmeta_header\x18\x02 \x01(\v2%.neo.fs.v2.session.ResponseMetaHeaderR\n" +
	"metaHeader\x12R\n" +
	"\rverify_header\x18\x03 \x01(\v2-.neo.fs.v2.session.ResponseVerificationHeaderR\fverifyHeader\x1a\xca\x01\n" +
	"\x04Body\x12<\n" +
	"\tcontainer\x18\x01 \x01(\v2\x1e.neo.fs.v2.container.ContainerR\tcontainer\x12>\n" +
	"\tsignature\x18\x02 \x01(\v2 .neo.fs.v2.refs.SignatureRFC6979R\tsignature\x12D\n" +
	"\rsession_token\x18\x03 \x01(\v2\x1f.neo.fs.v2.session.SessionTokenR\fsessionToken\"\x9e\x02\n" +
	"\vListRequest\x129\n" +
	"\x04body\x18\x01 \x01(\v2%.neo.fs.v2.container.ListRequest.BodyR\x04body\x12E\n" +
	"\vmeta_header\x18\x02 \x01(\v2$.neo.fs.v2.session.RequestMetaHeaderR\n" +
	"metaHeader\x12Q\n" +
	"\rverify_header\x18\x03 \x01(\v2,.neo.fs.v2.session.RequestVerificationHeaderR\fverifyHeader\x1a:\n" +
	"\x04Body\x122\n" +
	"\bowner_id\x18\x01 \x01(\v2\x17.neo.fs.v2.refs.OwnerIDR\aownerId\"\xb0\x02\n" +
	"\fListResponse\x12:\n" +
	"\x04body\x18\x01 \x01(\v2&.neo.fs.v2.container.ListResponse.BodyR\x04body\x12F\n" +
	"\vmeta_header\x18\x02 \x01(\v2%.neo.fs.v2.session.ResponseMetaHeaderR\n" +
	"metaHeader\x12R\n" +
	"\rverify_header\x18\x03 \x01(\v2-.neo.fs.v2.session.ResponseVerificationHeaderR\fverifyHeader\x1aH\n" +
	"\x04Body\x12@\n" +
	"\rcontainer_ids\x18\x01 \x03(\v2\x1b.neo.fs.v2.refs.ContainerIDR\fcontainerIds\"\xec\x02\n" +
	"\x15SetExtendedACLRequest\x12C\n" +
	"\x04body\x18\x01 \x01(\v2/.neo.fs.v2.container.SetExtendedACLRequest.BodyR\x04body\x12E\n" +
	"\vmeta_header\x18\x02 \x01(\v2$.neo.fs.v2.session.RequestMetaHeaderR\n" +
	"metaHeader\x12Q\n" +
	"\rverify_header\x18\x03 \x01(\v2,.neo.fs.v2.session.RequestVerificationHeaderR\fverifyHeader\x1at\n" +
	"\x04Body\x12,\n" +
	"\x04eacl\x18\x01 \x01(\v2\x18.neo.fs.v2.acl.EACLTableR\x04eacl\x12>\n" +
	"\tsignature\x18\x02 \x01(\v2 .neo.fs.v2.refs.SignatureRFC6979R\tsignature\"\x82\x02\n" +
	"\x16SetExtendedACLResponse\x12D\n" +
	"\x04body\x18\x01 \x01(\v20.neo.fs.v2.container.SetExtendedACLResponse.BodyR\x04body\x12F\n" +
	"\vmeta_header\x18\x02 \x01(\v2%.neo.fs.v2.session.ResponseMetaHeaderR\n" +
	"metaHeader\x12R\n" +
	"\rverify_header\x18\x03 \x01(\v2-.neo.fs.v2.session.ResponseVerificationHeaderR\fverifyHeader\x1a\x06\n" +
	"\x04Body\"\xbe\x02\n" +
	"\x15GetExtendedACLRequest\x12C\n" +
	"\x04body\x18\x01 \x01(\v2/.neo.fs.v2.container.GetExtendedACLRequest.BodyR\x04body\x12E\n" +
	"\vmeta_header\x18\x02 \x01(\v2$.neo.fs.v2.session.RequestMetaHeaderR\n" +
	"metaHeader\x12Q\n" +
	"\rverify_header\x18\x03 \x01(\v2,.neo.fs.v2.session.RequestVerificationHeaderR\fverifyHeader\x1aF\n" +
	"\x04Body\x12>\n" +
	"\fcontainer_id\x18\x01 \x01(\v2\x1b.neo.fs.v2.refs.ContainerIDR\vcontainerId\"\xb7\x03\n" +
	"\x16GetExtendedACLResponse\x12D\n" +
	"\x04body\x18\x01 \x01(\v20.neo.fs.v2.container.GetExtendedACLResponse.BodyR\x04body\x12F\n" +
	"\vmeta_header\x18\x02 \x01(\v2%.neo.fs.v2.session.ResponseMetaHeaderR\n" +
	"metaHeader\x12R\n" +
	"\rverify_header\x18\x03 \x01(\v2-.neo.fs.v2.session.ResponseVerificationHeaderR\fverifyHeader\x1a\xba\x01\n" +
	"\x04Body\x12,\n" +
	"\x04eacl\x18\x01 \x01(\v2\x18.neo.fs.v2.acl.EACLTableR\x04eacl\x12>\n" +
	"\tsignature\x18\x02 \x01(\v2 .neo.fs.v2.refs.SignatureRFC6979R\tsignature\x12D\n" +
	"\rsession_token\x18\x03 \x01(\v2\x1f.neo.fs.v2.session.SessionTokenR\fsessionToken\"\xf2\x03\n" +
	"\x18AnnounceUsedSpaceRequest\x12F\n" +
	"\x04body\x18\x01 \x01(\v22.neo.fs.v2.container.AnnounceUsedSpaceRequest.BodyR\x04body\x12E\n" +
	"\vmeta_header\x18\x02 \x01(\v2$.neo.fs.v2.session.RequestMetaHeaderR\n" +
	"metaHeader\x12Q\n" +
	"\rverify_header\x18\x03 \x01(\v2,.neo.fs.v2.session.RequestVerificationHeaderR\fverifyHeader\x1a\xf3\x01\n" +
	"\x04Body\x12e\n" +
	"\rannouncements\x18\x01 \x03(\v2?.neo.fs.v2.container.AnnounceUsedSpaceRequest.Body.AnnouncementR\rannouncements\x1a\x83\x01\n" +
	"\fAnnouncement\x12\x14\n" +
	"\x05epoch\x18\x01 \x01(\x04R\x05epoch\x12>\n" +
	"\fcontainer_id\x18\x02 \x01(\v2\x1b.neo.fs.v2.refs.ContainerIDR\vcontainerId\x12\x1d\n" +
	"\n" +
	"used_space\x18\x03 \x01(\x04R\tusedSpace\"\x88\x02\n" +
	"\x19AnnounceUsedSpaceResponse\x12G\n" +
	"\x04body\x18\x01 \x01(\v23.neo.fs.v2.container.AnnounceUsedSpaceResponse.BodyR\x04body\x12F\n" +
	"\vmeta_header\x18\x02 \x01(\v2%.neo.fs.v2.session.ResponseMetaHeaderR\n" +
	"metaHeader\x12R\n" +
	"\rverify_header\x18\x03 \x01(\v2-.neo.fs.v2.session.ResponseVerificationHeaderR\fverifyHeader\x1a\x06\n" +
	"\x04Body\"\xf4\x04\n" +
	"\x13SetAttributeRequest\x12A\n" +
	"\x04body\x18\x01 \x01(\v2-.neo.fs.v2.container.SetAttributeRequest.BodyR\x04body\x12@\n" +
	"\x0ebody_signature\x18\x02 \x01(\v2\x19.neo.fs.v2.refs.SignatureR\rbodySignature\x1a\xd7\x03\n" +
	"\x04Body\x12X\n" +
	"\n" +
	"parameters\x18\x01 \x01(\v28.neo.fs.v2.container.SetAttributeRequest.Body.ParametersR\n" +
	"parameters\x12>\n" +
	"\tsignature\x18\x02 \x01(\v2 .neo.fs.v2.refs.SignatureRFC6979R\tsignature\x12F\n" +
	"\rsession_token\x18\x03 \x01(\v2!.neo.fs.v2.session.SessionTokenV2R\fsessionToken\x12I\n" +
	"\x10session_token_v1\x18\x04 \x01(\v2\x1f.neo.fs.v2.session.SessionTokenR\x0esessionTokenV1\x1a\xa1\x01\n" +
	"\n" +
	"Parameters\x12>\n" +
	"\fcontainer_id\x18\x01 \x01(\v2\x1b.neo.fs.v2.refs.ContainerIDR\vcontainerId\x12\x1c\n" +
	"\tattribute\x18\x02 \x01(\tR\tattribute\x12\x14\n" +
	"\x05value\x18\x03 \x01(\tR\x05value\x12\x1f\n" +
	"\vvalid_until\x18\x04 \x01(\x04R\n" +
	"validUntil\"H\n" +
	"\x14SetAttributeResponse\x120\n" +
	"\x06status\x18\x01 \x01(\v2\x18.neo.fs.v2.status.StatusR\x06status\"\xe7\x04\n" +
	"\x16RemoveAttributeRequest\x12D\n" +
	"\x04body\x18\x01 \x01(\v20.neo.fs.v2.container.RemoveAttributeRequest.BodyR\x04body\x12@\n" +
	"\x0ebody_signature\x18\x02 \x01(\v2\x19.neo.fs.v2.refs.SignatureR\rbodySignature\x1a\xc4\x03\n" +
	"\x04Body\x12[\n" +
	"\n" +
	"parameters\x18\x01 \x01(\v2;.neo.fs.v2.container.RemoveAttributeRequest.Body.ParametersR\n" +
	"parameters\x12>\n" +
	"\tsignature\x18\x02 \x01(\v2 .neo.fs.v2.refs.SignatureRFC6979R\tsignature\x12F\n" +
	"\rsession_token\x18\x03 \x01(\v2!.neo.fs.v2.session.SessionTokenV2R\fsessionToken\x12I\n" +
	"\x10session_token_v1\x18\x04 \x01(\v2\x1f.neo.fs.v2.session.SessionTokenR\x0esessionTokenV1\x1a\x8b\x01\n" +
	"\n" +
	"Parameters\x12>\n" +
	"\fcontainer_id\x18\x01 \x01(\v2\x1b.neo.fs.v2.refs.ContainerIDR\vcontainerId\x12\x1c\n" +
	"\tattribute\x18\x02 \x01(\tR\tattribute\x12\x1f\n" +
	"\vvalid_until\x18\x03 \x01(\x04R\n" +
	"validUntil\"K\n" +
	"\x17RemoveAttributeResponse\x120\n" +
	"\x06status\x18\x01 \x01(\v2\x18.neo.fs.v2.status.StatusR\x06status2\xe3\x06\n" +
	"\x10ContainerService\x12H\n" +
	"\x03Put\x12\x1f.neo.fs.v2.container.PutRequest\x1a .neo.fs.v2.container.PutResponse\x12Q\n" +
	"\x06Delete\x12\".neo.fs.v2.container.DeleteRequest\x1a#.neo.fs.v2.container.DeleteResponse\x12H\n" +
	"\x03Get\x12\x1f.neo.fs.v2.container.GetRequest\x1a .neo.fs.v2.container.GetResponse\x12K\n" +
	"\x04List\x12 .neo.fs.v2.container.ListRequest\x1a!.neo.fs.v2.container.ListResponse\x12i\n" +
	"\x0eSetExtendedACL\x12*.neo.fs.v2.container.SetExtendedACLRequest\x1a+.neo.fs.v2.container.SetExtendedACLResponse\x12i\n" +
	"\x0eGetExtendedACL\x12*.neo.fs.v2.container.GetExtendedACLRequest\x1a+.neo.fs.v2.container.GetExtendedACLResponse\x12r\n" +
	"\x11AnnounceUsedSpace\x12-.neo.fs.v2.container.AnnounceUsedSpaceRequest\x1a..neo.fs.v2.container.AnnounceUsedSpaceResponse\x12c\n" +
	"\fSetAttribute\x12(.neo.fs.v2.container.SetAttributeRequest\x1a).neo.fs.v2.container.SetAttributeResponse\x12l\n" +
	"\x0fRemoveAttribute\x12+.neo.fs.v2.container.RemoveAttributeRequest\x1a,.neo.fs.v2.container.RemoveAttributeResponseBSZ1github.com/nspcc-dev/neofs-sdk-go/proto/container\xaa\x02\x1dNeo.FileStorage.API.Containerb\x06proto3"

var (
	file_proto_container_service_proto_rawDescOnce sync.Once
	file_proto_container_service_proto_rawDescData []byte
)

func file_proto_container_service_proto_rawDescGZIP() []byte {
	file_proto_container_service_proto_rawDescOnce.Do(func() {
		file_proto_container_service_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_proto_container_service_proto_rawDesc), len(file_proto_container_service_proto_rawDesc)))
	})
	return file_proto_container_service_proto_rawDescData
}

var file_proto_container_service_proto_msgTypes = make([]protoimpl.MessageInfo, 37)
var file_proto_container_service_proto_goTypes = []any{
	(*PutRequest)(nil),                                 // 0: neo.fs.v2.container.PutRequest
	(*PutResponse)(nil),                                // 1: neo.fs.v2.container.PutResponse
	(*DeleteRequest)(nil),                              // 2: neo.fs.v2.container.DeleteRequest
	(*DeleteResponse)(nil),                             // 3: neo.fs.v2.container.DeleteResponse
	(*GetRequest)(nil),                                 // 4: neo.fs.v2.container.GetRequest
	(*GetResponse)(nil),                                // 5: neo.fs.v2.container.GetResponse
	(*ListRequest)(nil),                                // 6: neo.fs.v2.container.ListRequest
	(*ListResponse)(nil),                               // 7: neo.fs.v2.container.ListResponse
	(*SetExtendedACLRequest)(nil),                      // 8: neo.fs.v2.container.SetExtendedACLRequest
	(*SetExtendedACLResponse)(nil),                     // 9: neo.fs.v2.container.SetExtendedACLResponse
	(*GetExtendedACLRequest)(nil),                      // 10: neo.fs.v2.container.GetExtendedACLRequest
	(*GetExtendedACLResponse)(nil),                     // 11: neo.fs.v2.container.GetExtendedACLResponse
	(*AnnounceUsedSpaceRequest)(nil),                   // 12: neo.fs.v2.container.AnnounceUsedSpaceRequest
	(*AnnounceUsedSpaceResponse)(nil),                  // 13: neo.fs.v2.container.AnnounceUsedSpaceResponse
	(*SetAttributeRequest)(nil),                        // 14: neo.fs.v2.container.SetAttributeRequest
	(*SetAttributeResponse)(nil),                       // 15: neo.fs.v2.container.SetAttributeResponse
	(*RemoveAttributeRequest)(nil),                     // 16: neo.fs.v2.container.RemoveAttributeRequest
	(*RemoveAttributeResponse)(nil),                    // 17: neo.fs.v2.container.RemoveAttributeResponse
	(*PutRequest_Body)(nil),                            // 18: neo.fs.v2.container.PutRequest.Body
	(*PutResponse_Body)(nil),                           // 19: neo.fs.v2.container.PutResponse.Body
	(*DeleteRequest_Body)(nil),                         // 20: neo.fs.v2.container.DeleteRequest.Body
	(*DeleteResponse_Body)(nil),                        // 21: neo.fs.v2.container.DeleteResponse.Body
	(*GetRequest_Body)(nil),                            // 22: neo.fs.v2.container.GetRequest.Body
	(*GetResponse_Body)(nil),                           // 23: neo.fs.v2.container.GetResponse.Body
	(*ListRequest_Body)(nil),                           // 24: neo.fs.v2.container.ListRequest.Body
	(*ListResponse_Body)(nil),                          // 25: neo.fs.v2.container.ListResponse.Body
	(*SetExtendedACLRequest_Body)(nil),                 // 26: neo.fs.v2.container.SetExtendedACLRequest.Body
	(*SetExtendedACLResponse_Body)(nil),                // 27: neo.fs.v2.container.SetExtendedACLResponse.Body
	(*GetExtendedACLRequest_Body)(nil),                 // 28: neo.fs.v2.container.GetExtendedACLRequest.Body
	(*GetExtendedACLResponse_Body)(nil),                // 29: neo.fs.v2.container.GetExtendedACLResponse.Body
	(*AnnounceUsedSpaceRequest_Body)(nil),              // 30: neo.fs.v2.container.AnnounceUsedSpaceRequest.Body
	(*AnnounceUsedSpaceRequest_Body_Announcement)(nil), // 31: neo.fs.v2.container.AnnounceUsedSpaceRequest.Body.Announcement
	(*AnnounceUsedSpaceResponse_Body)(nil),             // 32: neo.fs.v2.container.AnnounceUsedSpaceResponse.Body
	(*SetAttributeRequest_Body)(nil),                   // 33: neo.fs.v2.container.SetAttributeRequest.Body
	(*SetAttributeRequest_Body_Parameters)(nil),        // 34: neo.fs.v2.container.SetAttributeRequest.Body.Parameters
	(*RemoveAttributeRequest_Body)(nil),                // 35: neo.fs.v2.container.RemoveAttributeRequest.Body
	(*RemoveAttributeRequest_Body_Parameters)(nil),     // 36: neo.fs.v2.container.RemoveAttributeRequest.Body.Parameters
	(*session.RequestMetaHeader)(nil),                  // 37: neo.fs.v2.session.RequestMetaHeader
	(*session.RequestVerificationHeader)(nil),          // 38: neo.fs.v2.session.RequestVerificationHeader
	(*session.ResponseMetaHeader)(nil),                 // 39: neo.fs.v2.session.ResponseMetaHeader
	(*session.ResponseVerificationHeader)(nil),         // 40: neo.fs.v2.session.ResponseVerificationHeader
	(*refs.Signature)(nil),                             // 41: neo.fs.v2.refs.Signature
	(*status.Status)(nil),                              // 42: neo.fs.v2.status.Status
	(*Container)(nil),                                  // 43: neo.fs.v2.container.Container
	(*refs.SignatureRFC6979)(nil),                      // 44: neo.fs.v2.refs.SignatureRFC6979
	(*refs.ContainerID)(nil),                           // 45: neo.fs.v2.refs.ContainerID
	(*session.SessionToken)(nil),                       // 46: neo.fs.v2.session.SessionToken
	(*refs.OwnerID)(nil),                               // 47: neo.fs.v2.refs.OwnerID
	(*acl.EACLTable)(nil),                              // 48: neo.fs.v2.acl.EACLTable
	(*session.SessionTokenV2)(nil),                     // 49: neo.fs.v2.session.SessionTokenV2
}
var file_proto_container_service_proto_depIdxs = []int32{
	18, // 0: neo.fs.v2.container.PutRequest.body:type_name -> neo.fs.v2.container.PutRequest.Body
	37, // 1: neo.fs.v2.container.PutRequest.meta_header:type_name -> neo.fs.v2.session.RequestMetaHeader
	38, // 2: neo.fs.v2.container.PutRequest.verify_header:type_name -> neo.fs.v2.session.RequestVerificationHeader
	19, // 3: neo.fs.v2.container.PutResponse.body:type_name -> neo.fs.v2.container.PutResponse.Body
	39, // 4: neo.fs.v2.container.PutResponse.meta_header:type_name -> neo.fs.v2.session.ResponseMetaHeader
	40, // 5: neo.fs.v2.container.PutResponse.verify_header:type_name -> neo.fs.v2.session.ResponseVerificationHeader
	20, // 6: neo.fs.v2.container.DeleteRequest.body:type_name -> neo.fs.v2.container.DeleteRequest.Body
	37, // 7: neo.fs.v2.container.DeleteRequest.meta_header:type_name -> neo.fs.v2.session.RequestMetaHeader
	38, // 8: neo.fs.v2.container.DeleteRequest.verify_header:type_name -> neo.fs.v2.session.RequestVerificationHeader
	21, // 9: neo.fs.v2.container.DeleteResponse.body:type_name -> neo.fs.v2.container.DeleteResponse.Body
	39, // 10: neo.fs.v2.container.DeleteResponse.meta_header:type_name -> neo.fs.v2.session.ResponseMetaHeader
	40, // 11: neo.fs.v2.container.DeleteResponse.verify_header:type_name -> neo.fs.v2.session.ResponseVerificationHeader
	22, // 12: neo.fs.v2.container.GetRequest.body:type_name -> neo.fs.v2.container.GetRequest.Body
	37, // 13: neo.fs.v2.container.GetRequest.meta_header:type_name -> neo.fs.v2.session.RequestMetaHeader
	38, // 14: neo.fs.v2.container.GetRequest.verify_header:type_name -> neo.fs.v2.session.RequestVerificationHeader
	23, // 15: neo.fs.v2.container.GetResponse.body:type_name -> neo.fs.v2.container.GetResponse.Body
	39, // 16: neo.fs.v2.container.GetResponse.meta_header:type_name -> neo.fs.v2.session.ResponseMetaHeader
	40, // 17: neo.fs.v2.container.GetResponse.verify_header:type_name -> neo.fs.v2.session.ResponseVerificationHeader
	24, // 18: neo.fs.v2.container.ListRequest.body:type_name -> neo.fs.v2.container.ListRequest.Body
	37, // 19: neo.fs.v2.container.ListRequest.meta_header:type_name -> neo.fs.v2.session.RequestMetaHeader
	38, // 20: neo.fs.v2.container.ListRequest.verify_header:type_name -> neo.fs.v2.session.RequestVerificationHeader
	25, // 21: neo.fs.v2.container.ListResponse.body:type_name -> neo.fs.v2.container.ListResponse.Body
	39, // 22: neo.fs.v2.container.ListResponse.meta_header:type_name -> neo.fs.v2.session.ResponseMetaHeader
	40, // 23: neo.fs.v2.container.ListResponse.verify_header:type_name -> neo.fs.v2.session.ResponseVerificationHeader
	26, // 24: neo.fs.v2.container.SetExtendedACLRequest.body:type_name -> neo.fs.v2.container.SetExtendedACLRequest.Body
	37, // 25: neo.fs.v2.container.SetExtendedACLRequest.meta_header:type_name -> neo.fs.v2.session.RequestMetaHeader
	38, // 26: neo.fs.v2.container.SetExtendedACLRequest.verify_header:type_name -> neo.fs.v2.session.RequestVerificationHeader
	27, // 27: neo.fs.v2.container.SetExtendedACLResponse.body:type_name -> neo.fs.v2.container.SetExtendedACLResponse.Body
	39, // 28: neo.fs.v2.container.SetExtendedACLResponse.meta_header:type_name -> neo.fs.v2.session.ResponseMetaHeader
	40, // 29: neo.fs.v2.container.SetExtendedACLResponse.verify_header:type_name -> neo.fs.v2.session.ResponseVerificationHeader
	28, // 30: neo.fs.v2.container.GetExtendedACLRequest.body:type_name -> neo.fs.v2.container.GetExtendedACLRequest.Body
	37, // 31: neo.fs.v2.container.GetExtendedACLRequest.meta_header:type_name -> neo.fs.v2.session.RequestMetaHeader
	38, // 32: neo.fs.v2.container.GetExtendedACLRequest.verify_header:type_name -> neo.fs.v2.session.RequestVerificationHeader
	29, // 33: neo.fs.v2.container.GetExtendedACLResponse.body:type_name -> neo.fs.v2.container.GetExtendedACLResponse.Body
	39, // 34: neo.fs.v2.container.GetExtendedACLResponse.meta_header:type_name -> neo.fs.v2.session.ResponseMetaHeader
	40, // 35: neo.fs.v2.container.GetExtendedACLResponse.verify_header:type_name -> neo.fs.v2.session.ResponseVerificationHeader
	30, // 36: neo.fs.v2.container.AnnounceUsedSpaceRequest.body:type_name -> neo.fs.v2.container.AnnounceUsedSpaceRequest.Body
	37, // 37: neo.fs.v2.container.AnnounceUsedSpaceRequest.meta_header:type_name -> neo.fs.v2.session.RequestMetaHeader
	38, // 38: neo.fs.v2.container.AnnounceUsedSpaceRequest.verify_header:type_name -> neo.fs.v2.session.RequestVerificationHeader
	32, // 39: neo.fs.v2.container.AnnounceUsedSpaceResponse.body:type_name -> neo.fs.v2.container.AnnounceUsedSpaceResponse.Body
	39, // 40: neo.fs.v2.container.AnnounceUsedSpaceResponse.meta_header:type_name -> neo.fs.v2.session.ResponseMetaHeader
	40, // 41: neo.fs.v2.container.AnnounceUsedSpaceResponse.verify_header:type_name -> neo.fs.v2.session.ResponseVerificationHeader
	33, // 42: neo.fs.v2.container.SetAttributeRequest.body:type_name -> neo.fs.v2.container.SetAttributeRequest.Body
	41, // 43: neo.fs.v2.container.SetAttributeRequest.body_signature:type_name -> neo.fs.v2.refs.Signature
	42, // 44: neo.fs.v2.container.SetAttributeResponse.status:type_name -> neo.fs.v2.status.Status
	35, // 45: neo.fs.v2.container.RemoveAttributeRequest.body:type_name -> neo.fs.v2.container.RemoveAttributeRequest.Body
	41, // 46: neo.fs.v2.container.RemoveAttributeRequest.body_signature:type_name -> neo.fs.v2.refs.Signature
	42, // 47: neo.fs.v2.container.RemoveAttributeResponse.status:type_name -> neo.fs.v2.status.Status
	43, // 48: neo.fs.v2.container.PutRequest.Body.container:type_name -> neo.fs.v2.container.Container
	44, // 49: neo.fs.v2.container.PutRequest.Body.signature:type_name -> neo.fs.v2.refs.SignatureRFC6979
	45, // 50: neo.fs.v2.container.PutResponse.Body.container_id:type_name -> neo.fs.v2.refs.ContainerID
	45, // 51: neo.fs.v2.container.DeleteRequest.Body.container_id:type_name -> neo.fs.v2.refs.ContainerID
	44, // 52: neo.fs.v2.container.DeleteRequest.Body.signature:type_name -> neo.fs.v2.refs.SignatureRFC6979
	45, // 53: neo.fs.v2.container.GetRequest.Body.container_id:type_name -> neo.fs.v2.refs.ContainerID
	43, // 54: neo.fs.v2.container.GetResponse.Body.container:type_name -> neo.fs.v2.container.Container
	44, // 55: neo.fs.v2.container.GetResponse.Body.signature:type_name -> neo.fs.v2.refs.SignatureRFC6979
	46, // 56: neo.fs.v2.container.GetResponse.Body.session_token:type_name -> neo.fs.v2.session.SessionToken
	47, // 57: neo.fs.v2.container.ListRequest.Body.owner_id:type_name -> neo.fs.v2.refs.OwnerID
	45, // 58: neo.fs.v2.container.ListResponse.Body.container_ids:type_name -> neo.fs.v2.refs.ContainerID
	48, // 59: neo.fs.v2.container.SetExtendedACLRequest.Body.eacl:type_name -> neo.fs.v2.acl.EACLTable
	44, // 60: neo.fs.v2.container.SetExtendedACLRequest.Body.signature:type_name -> neo.fs.v2.refs.SignatureRFC6979
	45, // 61: neo.fs.v2.container.GetExtendedACLRequest.Body.container_id:type_name -> neo.fs.v2.refs.ContainerID
	48, // 62: neo.fs.v2.container.GetExtendedACLResponse.Body.eacl:type_name -> neo.fs.v2.acl.EACLTable
	44, // 63: neo.fs.v2.container.GetExtendedACLResponse.Body.signature:type_name -> neo.fs.v2.refs.SignatureRFC6979
	46, // 64: neo.fs.v2.container.GetExtendedACLResponse.Body.session_token:type_name -> neo.fs.v2.session.SessionToken
	31, // 65: neo.fs.v2.container.AnnounceUsedSpaceRequest.Body.announcements:type_name -> neo.fs.v2.container.AnnounceUsedSpaceRequest.Body.Announcement
	45, // 66: neo.fs.v2.container.AnnounceUsedSpaceRequest.Body.Announcement.container_id:type_name -> neo.fs.v2.refs.ContainerID
	34, // 67: neo.fs.v2.container.SetAttributeRequest.Body.parameters:type_name -> neo.fs.v2.container.SetAttributeRequest.Body.Parameters
	44, // 68: neo.fs.v2.container.SetAttributeRequest.Body.signature:type_name -> neo.fs.v2.refs.SignatureRFC6979
	49, // 69: neo.fs.v2.container.SetAttributeRequest.Body.session_token:type_name -> neo.fs.v2.session.SessionTokenV2
	46, // 70: neo.fs.v2.container.SetAttributeRequest.Body.session_token_v1:type_name -> neo.fs.v2.session.SessionToken
	45, // 71: neo.fs.v2.container.SetAttributeRequest.Body.Parameters.container_id:type_name -> neo.fs.v2.refs.ContainerID
	36, // 72: neo.fs.v2.container.RemoveAttributeRequest.Body.parameters:type_name -> neo.fs.v2.container.RemoveAttributeRequest.Body.Parameters
	44, // 73: neo.fs.v2.container.RemoveAttributeRequest.Body.signature:type_name -> neo.fs.v2.refs.SignatureRFC6979
	49, // 74: neo.fs.v2.container.RemoveAttributeRequest.Body.session_token:type_name -> neo.fs.v2.session.SessionTokenV2
	46, // 75: neo.fs.v2.container.RemoveAttributeRequest.Body.session_token_v1:type_name -> neo.fs.v2.session.SessionToken
	45, // 76: neo.fs.v2.container.RemoveAttributeRequest.Body.Parameters.container_id:type_name -> neo.fs.v2.refs.ContainerID
	0,  // 77: neo.fs.v2.container.ContainerService.Put:input_type -> neo.fs.v2.container.PutRequest
	2,  // 78: neo.fs.v2.container.ContainerService.Delete:input_type -> neo.fs.v2.container.DeleteRequest
	4,  // 79: neo.fs.v2.container.ContainerService.Get:input_type -> neo.fs.v2.container.GetRequest
	6,  // 80: neo.fs.v2.container.ContainerService.List:input_type -> neo.fs.v2.container.ListRequest
	8,  // 81: neo.fs.v2.container.ContainerService.SetExtendedACL:input_type -> neo.fs.v2.container.SetExtendedACLRequest
	10, // 82: neo.fs.v2.container.ContainerService.GetExtendedACL:input_type -> neo.fs.v2.container.GetExtendedACLRequest
	12, // 83: neo.fs.v2.container.ContainerService.AnnounceUsedSpace:input_type -> neo.fs.v2.container.AnnounceUsedSpaceRequest
	14, // 84: neo.fs.v2.container.ContainerService.SetAttribute:input_type -> neo.fs.v2.container.SetAttributeRequest
	16, // 85: neo.fs.v2.container.ContainerService.RemoveAttribute:input_type -> neo.fs.v2.container.RemoveAttributeRequest
	1,  // 86: neo.fs.v2.container.ContainerService.Put:output_type -> neo.fs.v2.container.PutResponse
	3,  // 87: neo.fs.v2.container.ContainerService.Delete:output_type -> neo.fs.v2.container.DeleteResponse
	5,  // 88: neo.fs.v2.container.ContainerService.Get:output_type -> neo.fs.v2.container.GetResponse
	7,  // 89: neo.fs.v2.container.ContainerService.List:output_type -> neo.fs.v2.container.ListResponse
	9,  // 90: neo.fs.v2.container.ContainerService.SetExtendedACL:output_type -> neo.fs.v2.container.SetExtendedACLResponse
	11, // 91: neo.fs.v2.container.ContainerService.GetExtendedACL:output_type -> neo.fs.v2.container.GetExtendedACLResponse
	13, // 92: neo.fs.v2.container.ContainerService.AnnounceUsedSpace:output_type -> neo.fs.v2.container.AnnounceUsedSpaceResponse
	15, // 93: neo.fs.v2.container.ContainerService.SetAttribute:output_type -> neo.fs.v2.container.SetAttributeResponse
	17, // 94: neo.fs.v2.container.ContainerService.RemoveAttribute:output_type -> neo.fs.v2.container.RemoveAttributeResponse
	86, // [86:95] is the sub-list for method output_type
	77, // [77:86] is the sub-list for method input_type
	77, // [77:77] is the sub-list for extension type_name
	77, // [77:77] is the sub-list for extension extendee
	0,  // [0:77] is the sub-list for field type_name
}

func init() { file_proto_container_service_proto_init() }
func file_proto_container_service_proto_init() {
	if File_proto_container_service_proto != nil {
		return
	}
	file_proto_container_types_proto_init()
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_proto_container_service_proto_rawDesc), len(file_proto_container_service_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   37,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_proto_container_service_proto_goTypes,
		DependencyIndexes: file_proto_container_service_proto_depIdxs,
		MessageInfos:      file_proto_container_service_proto_msgTypes,
	}.Build()
	File_proto_container_service_proto = out.File
	file_proto_container_service_proto_goTypes = nil
	file_proto_container_service_proto_depIdxs = nil
}
